

























[{"body":"Prerequisites   Compile with debug symbols. To do this, add the -g flag when you compile. For example, clang -g -o program.o program.c. For convenience, add a target to your makefile, i.e.:\ndebug: CFLAGS += -g debug: all   Launch GDB using ./gdb --args followed by the your normal method of execution. For example, for a program named program and one flag –flag, run gdb --args ./program --flags.\n  Once inside GDB, the command run will run your program.\n  Finding Segmentation Faults First, run your program using GDB. When your program crashes, you should see the exact line on which your program failed.\nFor more information, use the backtrace command. The stack trace should show the path your program took during its execution. For example, if your program crashes in the standard library’s strlen function, there won’t be much information there. Running backtrace will show you the arguments passed to the function and which function called strlen.\nExample $ gdb --args ./executable Reading symbols from ./executable... GDB has read the executable. The (gdb) prompt means anything typed is sent to GDB, not to the shell.\n(gdb) run Starting program: /path/to/executable Program received signal SIGSEGV, Segmentation fault. 0x000055555555512c in my_function (array=0x0) at ./segfault.c:4 4 return array[0]; The program received a segmentation fault in the function my_function. The function has one argument, array=0x0 (i.e., NULL).This is the source of the segmentation fault, since the code is attempting to access the 0th element of NULL memory.\n(gdb) backtrace #0 0x000055555555512c in my_function (array=0x0) at ./segfault.c:4 #1 0x0000555555555150 in main () at ./segfault.c:9 (gdb) The function my_function was called from the function main.\n","categories":"","description":"Debugging with GDB to identify segmentation faults.","excerpt":"Debugging with GDB to identify segmentation faults.","ref":"/ucsc-guide/docs/majorguides/computerscience/cprogramming/gdb/","tags":"","title":"Debugging with GDB"},{"body":"This page describes how to compile C programs that are more complex than a single source file. We’ll cover how to split code across multiple files, how to compile those files, how to automate the build process using GNU Make, and how to make use of system libraries.\nYou can follow along with this guide on your own computer. All you’ll need is familiarity with the command line and a C programming environment with recent versions of Clang and Make. I would recommend using Linux (either running on your computer, in a virtual machine, or in WSL2). These commands may also work on macOS if you install Clang and Make, but they will not work on Windows if you don’t have a Linux environment.\nOur program To get started, create an empty directory to hold all the files that we create. The name doesn’t matter. Navigate into that directory and create the following C file called hypot.c. This is the program that we will be working with. Given two side lengths of a right triangle, it calculates the length of the hypotenuse.\n// hypot.c #include \u003cstdio.h\u003e#include \u003cstdlib.h\u003e // approximation of sqrt(x) for some values of x unsigned int sqrts[] = { 0, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, }; unsigned int my_sqrt(unsigned int x) { if (x \u003e 25) { fprintf(stderr, \"error: cannot take sqrt of %u\\n\", x); exit(2); } return sqrts[x]; } double my_hypot(double a, double b) { return my_sqrt(a * a + b * b); } int main(void) { double a, b; printf(\"side a: \"); if (!scanf(\"%lf\", \u0026a)) { fprintf(stderr, \"invalid input\\n\"); return 1; } printf(\"side b: \"); if (!scanf(\"%lf\", \u0026b)) { fprintf(stderr, \"invalid input\\n\"); return 1; } printf(\"c = %lf\\n\", my_hypot(a, b)); return 0; } You may already know the command to compile this using Clang:\n$ clang -Wall -Werror -Wextra -Wpedantic -o hypot hypot.c But what does every part of this mean? Clang, like most command line programs, lets you specify input files (in this case, C files to compile) as well as flags that modify its behavior. Each argument that isn’t part of a flag is interpreted as an input file. Let’s break down all the arguments:\n -Wall, -Werror, -Wextra, -Wpedantic: each of these enables a certain class of warnings. Together, they make Clang very strict. With these flags, compilation will often fail when issues are encountered that would normally only be treated as warnings. -o, hypot: the o stands for “output,” and means that the next argument should be used as the output filename. This makes Clang save the executable file as hypot, and prevents hypot from being interpreted as an input filename. hypot.c: this is the only input file.  The compilation should succeed without errors. Now you can run the program:\n$ ./hypot side a: 3 side b: 4 c = 5.000000 It worked! But, as you might have noticed from the code, our calculation is extremely limited—the square root function only returns integer approximations for numbers between 0 and 25, and fails on any other numbers. Here’s an example:\n$ ./hypot side a: 2 side b: 2 c = 3.000000 The side length should be √8 ≈ 2.828. We’re going to modify this program to:\n use the built-in math library’s sqrt function move the my_hypot function into another file automatically compile with all the right parameters when we run make  Using the math library You may know that in order to call math functions like sqrt, you need to do two things: put #include \u003cmath.h\u003e at the top of your file, and add -lm to your compilation flags. What do these do?\nHeader files Including a file with #include inserts its contents at the position of the #include statement, nothing more. Since \u003cmath.h\u003e uses angle brackets instead of quotes, the preprocessor (which is responsible for processing includes, among other things) looks for a file in the include path, instead of the current directory. You can modify the include path, but the default (on Linux, at least) is /usr/include. This means that we are including /usr/include/math.h, a file that comes with the operating system. You can actually open and view this file! Sadly, it is full of macros and includes other files, so the actual declaration of sqrt is not easy to find, but you can imagine that somewhere in that file is the declaration:\ndouble sqrt(double x); (Since the preprocessor processes includes recursively, as far as you are concerned, that declaration may as well actually be in /usr/include/math.h. The fact that it isn’t is transparent to you.)\nLet’s change our program to use the system’s sqrt function (to make this tutorial easier to follow, when you modify a file, I’ll specify what the complete contents should now be):\n// hypot.c #include \u003cstdio.h\u003e#include \u003cstdlib.h\u003e// new line #include \u003cmath.h\u003e // deleted: sqrts array and my_sqrt function  double my_hypot(double a, double b) { // modified  return sqrt(a * a + b * b); } int main(void) { double a, b; printf(\"side a: \"); if (!scanf(\"%lf\", \u0026a)) { fprintf(stderr, \"invalid input\\n\"); return 1; } printf(\"side b: \"); if (!scanf(\"%lf\", \u0026b)) { fprintf(stderr, \"invalid input\\n\"); return 1; } printf(\"c = %lf\\n\", my_hypot(a, b)); return 0; } Linking against a system library Let’s recompile:\n$ clang -Wall -Wextra -Werror -Wpedantic hypot.c -o hypot /usr/bin/ld: /tmp/hypot-1e886c.o: in function `my_hypot': hypot.c:(.text+0x2b): undefined reference to `sqrt' clang-12: error: linker command failed with exit code 1 (use -v to see invocation) Uh oh! The important part of this error is undefined reference to `sqrt'. Remember that math.h contains only the declaration of sqrt. That essentially tells the compiler that there will be a function available, called sqrt, returning a double, and taking one double as its argument. However, to finish linking the binary, the linker needs to know what the address of that function will be at runtime, so that it can insert the proper function call. (We’ll get into the difference between compiling and linking later. For now, know that clang -Wall -Wextra -Werror -Wpedantic hypot.c -o hypot runs both steps, compiling and then linking your C file).\nWe can fix this error by linking against the math library. This is a shared library, meaning that its code can be used by any program on your computer, and the code is loaded dynamically when the program runs instead of being part of the executable. (All modern operating systems have shared libraries, but they use different file extensions. On Linux they are .so files, macOS uses .dylib, and Windows uses .dll.) Each executable contains a list of shared libraries that should be loaded, and linking against a shared library just adds its name to this list.\nLibrary names are prefixed with lib. The math library is libm. To link against a library, you use -l followed by the name of the library without the prefix, so the math library is -lm. Let’s recompile with this flag:\n$ clang -Wall -Wextra -Werror -Wpedantic hypot.c -o hypot -lm This time, the program handles the entire range of square roots:\n$ ./hypot side a: 2 side b: 2 c = 2.828427 Besides the fact that compilation succeeded, how do we know that the math library was linked properly? There’s a utility called ldd that lists which libraries a given executable links against. Let’s try it on our hypot binary:\n$ ldd hypot linux-vdso.so.1 (0x00007ffdc0912000) libm.so.6 =\u003e /usr/lib/libm.so.6 (0x00007fa15dbbd000) libc.so.6 =\u003e /usr/lib/libc.so.6 (0x00007fa15d9f1000) /lib64/ld-linux-x86-64.so.2 =\u003e /usr/lib64/ld-linux-x86-64.so.2 (0x00007fa15dd43000) The exact output may differ from system to system, but you should at least see libm and libc. libc is the standard C library, and it is linked by default. That’s why we can call functions like printf and scanf without any linker flags—they are part of libc.\nAnother interesting thing about this output is that it shows where each library is stored. On my system, they are all in /usr/lib. I tried this on an Ubuntu system and they were in /lib/x86_64-linux-gnu (suggesting that you could also have dynamic libraries installed for different CPU architectures). Fortunately, the system determines the exact path when your executable is running. This means I could copy my hypot executable onto an Ubuntu system (or copy an executable compiled on Ubuntu onto my system), and it would still find all the libraries it needs.\nSplitting up our program We have successfully modified our program to use the system’s sqrt function instead of our own janky one! All that remains is to, as promised, move the my_hypot function into its own file.\nWe’ll create two new files: a header, mathlib.h, and a C file, mathlib.c. Insert the following contents:\n// mathlib.h #pragma once  double my_hypot(double a, double b); // mathlib.c #include \"mathlib.h\" #include \u003cmath.h\u003e double my_hypot(double a, double b) { return sqrt(a * a + b * b); } The line #pragma once in mathlib.h ensures that the header file is only included once. It won’t make a difference in this tutorial, but in more advanced programs where one header file includes another header file (e.g. to get type definitions), you may get errors about multiple definitions of the contents of a header without #pragma once.\nWe also need to include the header file (not the C file!) from our main hypot.c. Add the #include statement:\n// hypot.c #include \u003cstdio.h\u003e#include \u003cstdlib.h\u003e#include \u003cmath.h\u003e// new line #include \"mathlib.h\" double my_hypot(double a, double b) { return sqrt(a * a + b * b); } int main(void) { double a, b; printf(\"side a: \"); if (!scanf(\"%lf\", \u0026a)) { fprintf(stderr, \"invalid input\\n\"); return 1; } printf(\"side b: \"); if (!scanf(\"%lf\", \u0026b)) { fprintf(stderr, \"invalid input\\n\"); return 1; } printf(\"c = %lf\\n\", my_hypot(a, b)); return 0; } We #include headers, not C files, because the C file is going to be compiled separately and linked. The file with the include statement only needs the declarations of functions, not definitions.\nYou may already be thinking of some other changes we’ll have to make to hypot.c. Let’s add mathlib.c as an input file to our last compilation command, and try compiling this:\n$ clang -Wall -Wextra -Werror -Wpedantic hypot.c mathlib.c -o hypot -lm /usr/bin/ld: /tmp/mathlib-5b7ded.o: in function `my_hypot': mathlib.c:(.text+0x0): multiple definition of `my_hypot'; /tmp/hypot-96432d.o:hypot.c:(.text+0x0): first defined here clang-12: error: linker command failed with exit code 1 (use -v to see invocation) Zeroing in on that error, the main issue is multiple definition of `my_hypot'. It says that one definition is in mathlib.c and another is in hypot.c. Let’s remove the one in hypot.c (we also remove #include \u003cmath.h\u003e since this file no longer needs to call sqrt):\n#include \u003cstdio.h\u003e#include \u003cstdlib.h\u003e #include \"mathlib.h\" // my_hypot function removed  int main(void) { double a, b; printf(\"side a: \"); if (!scanf(\"%lf\", \u0026a)) { fprintf(stderr, \"invalid input\\n\"); return 1; } printf(\"side b: \"); if (!scanf(\"%lf\", \u0026b)) { fprintf(stderr, \"invalid input\\n\"); return 1; } printf(\"c = %lf\\n\", my_hypot(a, b)); return 0; } If we compile this using the same command as before, it works!\nAutomating compilation with Make We’re almost ready to reduce our entire compilation process to just one command, but first we must learn one more concept.\nObject files An executable file (like the hypot file that we are creating) contains several things:\n machine code for every function in your program an entry point (in C, the main function) where execution should begin data that the program will need when it runs (e.g. the \"side a: \") string that we print space for global variables a list of dynamic libraries that should be loaded  An object file is similar to an executable, but different in some important ways. At the fundamental level, object files still contain executable code. An executable file is your whole program, but for programs with multiple source files, an object file is the compiled version of a single C file. Since object files cannot run on their own, they don’t have an entry point (they could have a function called main, however). Also, in an executable file, every function that’s referenced must be defined either in the executable itself, or in a dynamic library that is linked. Object files can reference external functions.\nTo compile a C program, you compile each C file into an object file, and then link those object files into one executable. Even if you don’t list these steps explicitly, Clang still performs both steps; it just deletes the object files when it’s done. The linking process entails:\n combining all the code in the various object files, making sure there are no functions with the same name for each function call, figuring out where that function will actually be located (in the binary or in a dynamic library) at runtime making sure there is a main function, and marking it as the entry point producing the final binary  Manually compiling and linking First, let’s run the commands to compile our C files to object files and link them. This is what make will eventually do for us.\nThe -c flag tells Clang to output an object file instead of an executable. By default, it will just replace .c with .o, but you can also specify the location of the object file manually with -o. Delete the hypot binary if you still have it from a previous section, and then let’s compile hypot.c and see what it creates:\n$ clang -Wall -Wextra -Werror -Wpedantic -c hypot.c $ ls hypot.c hypot.o mathlib.c mathlib.h Even though hypot.c uses functions from mathlib.c, it compiles just fine. But let’s try linking it. The command to link object files is the same as the command to link C files, except you specify object files as input. We also omit the warning flags, since those only affect the compiler, not the linker.\n$ clang hypot.o -o hypot /usr/bin/ld: hypot.o: in function `main': hypot.c:(.text+0xc1): undefined reference to `my_hypot' clang-12: error: linker command failed with exit code 1 (use -v to see invocation) It’s complaining that it can’t find the my_hypot function, since that is in a different file. Note that we got this error during linking and not compilation, since object files are allowed to reference functions from other files. Let’s compile mathlib.c into an object file and try again:\n$ clang -Wall -Wextra -Werror -Wpedantic -c mathlib.c $ ls hypot.c hypot.o mathlib.c mathlib.h mathlib.o $ clang hypot.o mathlib.o -o hypot /usr/bin/ld: mathlib.o: in function `my_hypot': mathlib.c:(.text+0x2b): undefined reference to `sqrt' clang-12: error: linker command failed with exit code 1 (use -v to see invocation) Now it can find my_hypot, but it still can’t find sqrt since we aren’t linking the math library. We can add the -lm flag the same way as before:\n$ clang -lm hypot.o mathlib.o -o hypot $ ls hypot hypot.c hypot.o mathlib.c mathlib.h mathlib.o It worked!\nCurrently, after changing our code, we would have to:\n recompile any C file(s) that we changed into new object files link all our object files (including ones that didn’t change) into a new binary  This will become impractical quickly. Let’s automate it!\nMake Make is a utility to automate your build process. It reads a Makefile (which is just a text file exactly called Makefile) for instructions on how to produce various files, and builds the one that you specified.\nThe true power of Make lies in its dependency system. You can specify the files that a file depends on (for instance, our binary hypot depends on the object files hypot.o and mathlib.o). When you use Make to build one file, it will automatically build all the file’s dependencies. But it will also look at when the various files were modified, and avoid rebuilding dependencies that have not changed since the file that depends on them was rebuilt. In our example, this means that if we run make, change hypot.c, and run make again, it won’t bother recompiling mathlib.c. This saves a lot of time for large programs!\nWe’re going to build up our Makefile a little bit at a time. Create a file called Makefile with the following contents:\nCC = clang CFLAGS = -Wall -Wextra -Werror -Wpedantic LDFLAGS = -lm EXEC = hypot OBJS = hypot.o mathlib.o These are variables that we’ll use later in the Makefile.\n CC is the name of the C compiler that we use CFLAGS are the flags that are passed to the compiler LDFLAGS are the flags that are passed to the linker EXEC is the name of the executable file we are making OBJS is the list of object files that we want to compile and link  Let’s add the next parts to our Makefile:\nCC = clang CFLAGS = -Wall -Wextra -Werror -Wpedantic LDFLAGS = -lm EXEC = hypot OBJS = hypot.o mathlib.o $(EXEC): $(OBJS) $(CC) $(LDFLAGS) -o $(EXEC) $(OBJS) Make sure the last line is indented with tabs, not spaces. Make requires tabs.\nThis looks complicated! The main thing going on is that $(VAR) gets replaced with the variable VAR. If we perform those replacements manually, those last two lines look like:\nhypot: hypot.o mathlib.o clang -lm -o hypot hypot.o mathlib.o This is one target. A target begins with the line target: dependencies, so in this case we are saying that hypot is a target which depends on hypot.o and mathlib.o. After this line come the command(s) to build that file, indented with tabs. You can see that, after all the variables have been substituted, the command here is the same as we were already using to link the executable.\nLet’s keep going! Next we’ll add targets to build our object files:\nCC = clang CFLAGS = -Wall -Wextra -Werror -Wpedantic LDFLAGS = -lm EXEC = hypot OBJS = hypot.o mathlib.o $(EXEC): $(OBJS) $(CC) $(LDFLAGS) -o $(EXEC) $(OBJS) hypot.o: hypot.c $(CC) $(CFLAGS) -c hypot.c mathlib.o: mathlib.c $(CC) $(CFLAGS) -c mathlib.c We list the C files as dependencies of these targets to ensure that each object file gets rebuilt when its corresponding C file changes. But unlike the previous example, the C files will not get their own targets in the Makefile, since those files are created by us and not Make. Since Make knows it isn’t responsible for creating the C files, it will just check that each one exists before it tries to build the object file, and throw an error if one is missing.\nWe’re going to add some more to the Makefile, but this is already enough to build our program! Let’s try it out. To build a Make target, just run make \u003ctarget name\u003e in the directory containing the Makefile. If you don’t specify a target, it will use the first one that is defined. In our Makefile, that is the $(EXEC) rule, so we are good to go. Make sure to delete your object files and executable, if you still have them from previous sections.\n$ ls hypot hypot.c hypot.o Makefile mathlib.c mathlib.h mathlib.o $ rm hypot *.o $ ls hypot.c Makefile mathlib.c mathlib.h $ make clang -Wall -Wextra -Werror -Wpedantic -c hypot.c clang -Wall -Wextra -Werror -Wpedantic -c mathlib.c clang -lm -o hypot hypot.o mathlib.o $ ls hypot hypot.c hypot.o Makefile mathlib.c mathlib.h mathlib.o $ ./hypot side a: 2 side b: 3 c = 3.605551 It worked! Note how Make prints out the commands that it runs. Let’s try compiling it again:\n$ make make: 'hypot' is up to date. It didn’t recompile because it has already built everything that it needs, and we didn’t change our C files.\nA more advanced Makefile This Makefile works fine, but it can do more. We’re going to make a few changes.\nSeparate all target In a more advanced project, you might have multiple executable files that should be compiled. Right now, we couldn’t run make to compile multiple executables, because it only runs the first target by default.\nWe can use something called a phony target to remedy this. A phony target is a target that doesn’t correspond to a single file. In this case, we create a target called all with all our executables (there is still only one, but there could be more) as dependencies, and put it first in the Makefile:\nCC = clang CFLAGS = -Wall -Wextra -Werror -Wpedantic LDFLAGS = -lm EXEC = hypot OBJS = hypot.o mathlib.o all: $(EXEC) $(EXEC): $(OBJS) $(CC) $(LDFLAGS) -o $(EXEC) $(OBJS) hypot.o: hypot.c $(CC) $(CFLAGS) -c hypot.c mathlib.o: mathlib.c $(CC) $(CFLAGS) -c mathlib.c We’ve listed hypot as the sole dependency of the all target. If there were a file called all in our project, we would need to name this target something else, because Make would think that it had already been built. Note that there are no commands to build all, because it will still run the commands to build hypot. Feel free to try deleting the executable and/or object files and running make again.\nCleanup It’s common to include a target called clean that deletes all executables and object files. We’ll do this using rm with the -f flag (“force”). The flag means that if we ask it to delete a file that doesn’t exist, it will silently ignore that argument instead of producing an error, so we can still run our clean target even if there isn’t anything for it to delete.\nCC = clang CFLAGS = -Wall -Wextra -Werror -Wpedantic LDFLAGS = -lm EXEC = hypot OBJS = hypot.o mathlib.o all: $(EXEC) $(EXEC): $(OBJS) $(CC) $(LDFLAGS) -o $(EXEC) $(OBJS) hypot.o: hypot.c $(CC) $(CFLAGS) -c hypot.c mathlib.o: mathlib.c $(CC) $(CFLAGS) -c mathlib.c clean: rm -f $(EXEC) $(OBJS) clean has no dependencies, and the command uses our variables to delete the files that it should. Let’s try it, first using make to make sure our program is compiled.\n$ make make: Nothing to be done for 'all'. $ ls hypot hypot.c hypot.o Makefile mathlib.c mathlib.h mathlib.o $ make clean rm -f hypot hypot.o mathlib.o $ ls hypot.c Makefile mathlib.c mathlib.h Automatically compiling object files Right now, if we added another C file to our program, we’d have to add a new target to our Makefile and copy the command to compile it. This can get unwieldy, and we run the risk of introducing a subtle bug by copying the command incorrectly.\nFortunately, Make allows us to specify much more general rules. Specifically, we can tell it how to compile any object file from the corresponding C file:\nCC = clang CFLAGS = -Wall -Wextra -Werror -Wpedantic LDFLAGS = -lm EXEC = hypot OBJS = hypot.o mathlib.o all: $(EXEC) $(EXEC): $(OBJS) $(CC) $(LDFLAGS) -o $(EXEC) $(OBJS) %.o: %.c $(CC) $(CFLAGS) -c $\u003c clean: rm -f $(EXEC) $(OBJS) The syntax here is tricky. The % symbols create a correspondence between the names of the object file and C file: any filename ending with .o depends on the same filename but with .c instead of .o. In the compilation command, $\u003c gets replaced with the name of the dependency, i.e. the name of the C file.\nLet’s check that this works, using make clean first to make sure it has to recompile everything:\n$ make clean rm -f hypot hypot.o mathlib.o $ ls hypot.c Makefile mathlib.c mathlib.h $ make clang -Wall -Wextra -Werror -Wpedantic -c hypot.c clang -Wall -Wextra -Werror -Wpedantic -c mathlib.c clang -lm -o hypot hypot.o mathlib.o $ ls hypot hypot.c hypot.o Makefile mathlib.c mathlib.h mathlib.o And it does!\nFormatting with clang-format If you use clang-format and have a configuration file (.clang-format) next to your code, you can add a target to run it with make format (here, the rest of the Makefile is omitted, since the target is not specific to our code):\nformat: clang-format -i -style=file *.[ch] Static analysis with scan-build scan-build is a program that detects additional problems with your code at compile time (that a compiler normally would not). We can also call it with a Makefile target:\nscan-build: clean scan-build --use-cc=$(CC) make This target isn’t as straightforward as the clang-format one. Some details to note are:\n scan-build’s argument is the command that builds our program. Here, that is just make. We list clean as a dependency. This ensures that all object files and executables are deleted before we run scan-build, so when scan-build runs make, the whole program is rebuilt. scan-build sometimes overrides the compiler used by Make. We specify --use-cc=$(CC) (effectively --use-cc=clang) to make sure that it will run using the same compiler that we normally use (as opposed to, say, GCC).  Here’s an example of running it:\n$ make scan-build rm -f hypot hypot.o mathlib.o scan-build --use-cc=clang make scan-build: Using '/usr/bin/clang-12' for static analysis make[1]: warning: jobserver unavailable: using -j1. Add '+' to parent make rule. make[1]: Entering directory '/home/ben/code/c/ucsc-guide-hypot' /usr/bin/../lib/clang/ccc-analyzer -Wall -Wextra -Werror -Wpedantic -c hypot.c /usr/bin/../lib/clang/ccc-analyzer -Wall -Wextra -Werror -Wpedantic -c mathlib.c /usr/bin/../lib/clang/ccc-analyzer -lm -o hypot hypot.o mathlib.o make[1]: Leaving directory '/home/ben/code/c/ucsc-guide-hypot' scan-build: Analysis run complete. scan-build: Removing directory '/tmp/scan-build-2021-10-11-005941-146456-1' because it contains no reports. scan-build: No bugs found. Expanding our program You’ve now seen everything you need to know to use Makefiles. In this last section, I will demonstrate how the build process would change if you wanted to add more C files to your project. We’re going to add one more C file and also have our Makefile compile a second binary in addition to hypot.\nIn the spirit of CSE 13S assignment 2, we’ll build a test harness that compares the results of our my_hypot function with the standard library’s hypot. The results should be identical, since we’re also using the standard library’s sqrt function and the calculation for what to take the square root of is trivial, but doing this will let us expand on our program.\nHere’s the code for the test harness. Save it in hypot-test.c:\n// hypot-test.c #include \u003cmath.h\u003e#include \u003cstdio.h\u003e #include \"mathlib.h\" int main(void) { for (double a = 1.0; a \u003c= 4.0; a += 1.0) { for (double b = 1.0; b \u003c= 4.0; b += 1.0) { double hypot_result = hypot(a, b), my_hypot_result = my_hypot(a, b), difference = fabs(hypot_result - my_hypot_result); printf(\"a = %.0f, b = %.0f: hypot = %16.15lf, my_hypot = %16.15lf, diff \" \"= %16.15lf\\n\", a, b, hypot_result, my_hypot_result, difference); } } return 0; } We can compile it manually, making sure to link against the math library and our own mathlib.o (run make again if you don’t have the object file):\n$ clang -Wall -Werror -Wextra -Wpedantic -c hypot-test.c $ clang -lm -o hypot-test hypot-test.o mathlib.o $ ./hypot-test a = 1, b = 1: hypot = 1.414213562373095, my_hypot = 1.414213562373095, diff = 0.000000000000000 a = 1, b = 2: hypot = 2.236067977499790, my_hypot = 2.236067977499790, diff = 0.000000000000000 a = 1, b = 3: hypot = 3.162277660168380, my_hypot = 3.162277660168380, diff = 0.000000000000000 a = 1, b = 4: hypot = 4.123105625617661, my_hypot = 4.123105625617661, diff = 0.000000000000000 a = 2, b = 1: hypot = 2.236067977499790, my_hypot = 2.236067977499790, diff = 0.000000000000000 a = 2, b = 2: hypot = 2.828427124746190, my_hypot = 2.828427124746190, diff = 0.000000000000000 a = 2, b = 3: hypot = 3.605551275463989, my_hypot = 3.605551275463989, diff = 0.000000000000000 a = 2, b = 4: hypot = 4.472135954999580, my_hypot = 4.472135954999580, diff = 0.000000000000000 a = 3, b = 1: hypot = 3.162277660168380, my_hypot = 3.162277660168380, diff = 0.000000000000000 a = 3, b = 2: hypot = 3.605551275463989, my_hypot = 3.605551275463989, diff = 0.000000000000000 a = 3, b = 3: hypot = 4.242640687119285, my_hypot = 4.242640687119285, diff = 0.000000000000000 a = 3, b = 4: hypot = 5.000000000000000, my_hypot = 5.000000000000000, diff = 0.000000000000000 a = 4, b = 1: hypot = 4.123105625617661, my_hypot = 4.123105625617661, diff = 0.000000000000000 a = 4, b = 2: hypot = 4.472135954999580, my_hypot = 4.472135954999580, diff = 0.000000000000000 a = 4, b = 3: hypot = 5.000000000000000, my_hypot = 5.000000000000000, diff = 0.000000000000000 a = 4, b = 4: hypot = 5.656854249492381, my_hypot = 5.656854249492381, diff = 0.000000000000000 Next, let’s modify our Makefile to automatically build hypot-test. First, we’ll rename the existing OBJS to HYPOT_OBJS, since we’ll eventually create a new list of object files that are needed for hypot-test. We’ll also remove the EXEC variable and instead write hypot directly:\nCC = clang CFLAGS = -Wall -Wextra -Werror -Wpedantic LDFLAGS = -lm HYPOT_OBJS = hypot.o mathlib.o all: hypot hypot: $(HYPOT_OBJS) $(CC) $(LDFLAGS) -o hypot $(HYPOT_OBJS) %.o: %.c $(CC) $(CFLAGS) -c $\u003c clean: rm -f hypot $(HYPOT_OBJS) format: clang-format -i -style=file *.[ch] scan-build: clean scan-build --use-cc=$(CC) make Now we can add HYPOT_TEST_OBJS with the object files that this program needs, as well as a hypot-test target. We’ll also add hypot-test as a dependency of the all target, so that running make with no arguments builds both hypot and hypot-test. And finally, we’ll add the executable and object files to our clean target:\nCC = clang CFLAGS = -Wall -Wextra -Werror -Wpedantic LDFLAGS = -lm HYPOT_OBJS = hypot.o mathlib.o HYPOT_TEST_OBJS = hypot-test.o mathlib.o all: hypot hypot-test hypot: $(HYPOT_OBJS) $(CC) $(LDFLAGS) -o hypot $(HYPOT_OBJS) hypot-test: $(HYPOT_TEST_OBJS) $(CC) $(LDFLAGS) -o hypot-test $(HYPOT_TEST_OBJS) %.o: %.c $(CC) $(CFLAGS) -c $\u003c clean: rm -f hypot hypot-test $(HYPOT_OBJS) $(HYPOT_TEST_OBJS) format: clang-format -i -style=file *.[ch] scan-build: clean scan-build --use-cc=$(CC) make Let’s test this out by running make clean and then having it recompile everything with make:\n$ ls hypot hypot.o hypot-test.c Makefile mathlib.h hypot.c hypot-test hypot-test.o mathlib.c mathlib.o $ make clean rm -f hypot hypot-test hypot.o mathlib.o hypot-test.o mathlib.o $ ls hypot.c hypot-test.c Makefile mathlib.c mathlib.h $ make clang -Wall -Wextra -Werror -Wpedantic -c hypot.c clang -Wall -Wextra -Werror -Wpedantic -c mathlib.c clang -Wall -Wextra -Werror -Wpedantic -c hypot-test.c clang -lm -o hypot hypot.o mathlib.o clang -lm -o hypot-test hypot-test.o mathlib.o $ ls hypot hypot.o hypot-test.c Makefile mathlib.h hypot.c hypot-test hypot-test.o mathlib.c mathlib.o $ ./hypot side a: 3 side b: 4 c = 5.000000 $ ./hypot-test a = 1, b = 1: hypot = 1.414213562373095, my_hypot = 1.414213562373095, diff = 0.000000000000000 a = 1, b = 2: hypot = 2.236067977499790, my_hypot = 2.236067977499790, diff = 0.000000000000000 a = 1, b = 3: hypot = 3.162277660168380, my_hypot = 3.162277660168380, diff = 0.000000000000000 a = 1, b = 4: hypot = 4.123105625617661, my_hypot = 4.123105625617661, diff = 0.000000000000000 a = 2, b = 1: hypot = 2.236067977499790, my_hypot = 2.236067977499790, diff = 0.000000000000000 a = 2, b = 2: hypot = 2.828427124746190, my_hypot = 2.828427124746190, diff = 0.000000000000000 a = 2, b = 3: hypot = 3.605551275463989, my_hypot = 3.605551275463989, diff = 0.000000000000000 a = 2, b = 4: hypot = 4.472135954999580, my_hypot = 4.472135954999580, diff = 0.000000000000000 a = 3, b = 1: hypot = 3.162277660168380, my_hypot = 3.162277660168380, diff = 0.000000000000000 a = 3, b = 2: hypot = 3.605551275463989, my_hypot = 3.605551275463989, diff = 0.000000000000000 a = 3, b = 3: hypot = 4.242640687119285, my_hypot = 4.242640687119285, diff = 0.000000000000000 a = 3, b = 4: hypot = 5.000000000000000, my_hypot = 5.000000000000000, diff = 0.000000000000000 a = 4, b = 1: hypot = 4.123105625617661, my_hypot = 4.123105625617661, diff = 0.000000000000000 a = 4, b = 2: hypot = 4.472135954999580, my_hypot = 4.472135954999580, diff = 0.000000000000000 a = 4, b = 3: hypot = 5.000000000000000, my_hypot = 5.000000000000000, diff = 0.000000000000000 a = 4, b = 4: hypot = 5.656854249492381, my_hypot = 5.656854249492381, diff = 0.000000000000000 It all worked! Make handles building multiple binaries very well—notice how it only built mathlib.c once, even though it is needed by both binaries. Also, this Makefile compiles both binaries by default (thanks to the all target), but you can also compile only one binary with make hypot or make hypot-test.\n","categories":"","description":"Compilation, linking, header files, object files, and Makefiles\n","excerpt":"Compilation, linking, header files, object files, and Makefiles\n","ref":"/ucsc-guide/docs/majorguides/computerscience/cprogramming/compilation/","tags":"","title":"Compilation"},{"body":"This section is designed as an introduction into C for use in lower division courses, such as CSE 13S. This section will link to official reference and other resources when possible.\n Prerequisites  A basic understanding of programming concepts, such as variables, if statements, loops, and functions. If you do not have any programming experience, it is highly recommended that you read the section on Python first. A Linux virtual machine or box. (Ubuntu 20.04 recommended) A basic understanding of how the terminal works on your distribution of Linux. If you do have not used a Linux before, it is recommended that you read the section on Unix first.   Background C is a a very simple language. It was developed in the 1970s by Dennis Ritchie. The language was eventually standardized in 1989 by ANSI. This version would become known as ANSI C, also referred to as C89. Over the years, newer versions of the C standard have been published. This section will primarily be covering basic C features up until C99.\n Hello world 1 2 3 4 5 6 7  #include \u003cstdio.h\u003e int main(void) { printf( \"Hello World!\\n\" ); return 0; }   The above code shows one of the ways to write a “Hello World” program in C. A “Hello World” program is a program that prints “Hello World” or some variation to the terminal. This program may look a little intimidating at first for someone who hasn’t seen C code before, but rest assured, each part of the code will be explained eventually through this section’s articles.\nLine 1 shows a #include preprocessor directive. The #include directive will be covered more in-depth in the “Writing programs” section. Preprocessor directives in general will be covered later in the “Building programs” section. For now, all you need to know about this line is that it enables us to use the printf function.\nLine 3 shows a function signature. A function signature contains information about a function. This function in specific is called the main function. When defined, it is the function that is called when the program is run. Functions will be covered later in the “Functions” section.\nLine 4 shows a call to the printf function. In this case, printf is used to print (output) \"Hello World!\\n\" to the standard output. Standard output will be explained in the “Standard Input/Output/Error” section. \\n is put at the end to print a new line. Unlike many other programming languages' print statements/functions/methods, C’s printf does not automatically add a new line at the end of the string to be printed. You will need to do so manually.\nLine 6 makes the program return with error code 0. In C, the main function returns error codes. An error code of 0 indicates that the program exited without an error. A non-zero error code indicates that the program exited with an error. Return statements and values will be covered more in-depth in the “Functions” section.\nIf you are still confused about how this program works, do not worry. Each part of it will eventually be covered in this section’s articles.\nAdditional resources The definitive book on C is The C Programming Language, by Brian Kernighan and Dennis Ritchie (the book is often called “K\u0026R” after the author’s last initials). It’s concise, well-written, and generally a model for excellent technical writing. The second and most recent edition was published all the way back in 1988, but C has not changed much since then, so it is still a great resource. It can easily be found legally (for money) or illegally (for free) online.\n","categories":"","description":"Introduction to C programming.\n","excerpt":"Introduction to C programming.\n","ref":"/ucsc-guide/docs/majorguides/computerscience/cprogramming/","tags":"","title":"C Programming"},{"body":"The proof building skills you gain from this class will be foundational for your success in CSE 102. They may look intimidating but the most comforting advice I have received from my teachers and tutors is that notation is half the problem. Once you work your way through the notations in the problem, you can start to understand what you are looking at and think of approaches to solutions. The following are just previews into common proof techniques from CSE 16 and 102.\n Note: Sometimes professors say which proof technique to use and sometimes it’s not explicitly stated, so you will need to pick a valid proof technique that can get you the desired result. So these are just good skills to keep in mind when creating a proof. Don’t worry - proof get a little easier and make more sense with practice!\n  Contradiction The starting point for a proof by contradiction can be a little tricky, but it is fun when you get the hang of it. A common set up is simply “prove this” and it gives you some expression to prove. The way a proof by contradiction works is that you take the negation of what was given and assme those are True as your “givens” to start with, then you continue using those negated expressions to see if you derive a contradiction (or something that cannot possibly be True). I will give and explain one example below.\nExample Prove the $\\sqrt{2}$ is irrational.\nThe first thing to do in a proof by contraction is to negate what is given and then assume that as a hypothesis.\nWe assume $\\sqrt{2}$ is rational and use various mathematical definitions to try to find a contradiction. The idea here is that we have to explore the world to see what would happen if $\\sqrt{2}$ is indeed rational and look for something that doesn’t make sense. In this problem, we will see that the greatest common divisor between two number is found to be 1 and not 1 at the same time. This is the contradiction because this cannot be true. So we can conclude the $\\sqrt{2}$ is irrational because if was rational then we have shown that a contradiction arises.\n Note: $gcd(a, b)$ is the greatest common divisor between $a$ and $b$. In this problem, we will be concerned about $gcd(a, b) = 1$, which means that $\\frac{a}{b}$ is in its simplest form and $gcd(a, b) \\neq 1$, which means $\\frac{a}{b}$ is not in its simplest form.\n The proof goes like this:\n Assume $\\sqrt{2}$ is rational. This means $\\sqrt{2}$ made up of some $\\frac{a}{b}$ where $a, b \\in \\mathbb{Z}$ and $b \\neq 0$ and $gcd(a, b) = 1$. Now, $\\sqrt{2} = \\frac{a}{b}$. Some rearranging gives, $2 = \\frac{a^2}{b^2}$. Solve for $a^2$ gives $a^2 = 2b^2$. Using a theorem that says if $a^2$ then, $a$ is even too (it’s a fun, quick proof to prove this theorem, try it), we can see that 2 divides $a$ evenly because the theorem says $a$ is even, so it’s a multiple of 2. Then from $2 = \\frac{a^2}{b^2}$, we can solve for $b^2$ to get $b^2 = 2a^2$. Same as above, we can see that $b^2$ is even and it follows that $b$ is even. Now, we have something that doesn’t make sense. We found that $a$ and $b$ are both even, which means that 2 can divide them both, which means $gcd(a, b) \\neq 1$. However, earlier in proof, we stated that the $gcd(a, b)$ is 1. These both cannot be true at the same time, so we can conclude that the $\\sqrt{2}$ is irrational because otherwise there would be an inconsistency.  Formal Proof Rules Before we get to the next techniques, you need to be familiar with what is and how to make a formal proof. In general, these are made with two columns, left side has the mathematical expressions and the work shown and the right side as the name of the rule or explanation of the reasoning that you used to get to that result. A couple rules and then the example to tie it all together:\n Two columns: left has the actual expressions, right has the name of the the rule you applied and the line numbers for the expressions involved. Number each line starting from 1.  I know it is annoying to always “show your work”, but it is easy to get lost or make a small mistake in the proof and then the answer is off or you cannot get to the correct answer. There are many ways to make a proof for a given problem, so these rules are in place to make it clear to the reader how you solved it and to yourself to follow your process to easily backtrack if something went wrong. Believe me, it is a time saver.\n Contrapositive The contrapositive is also an interesting proof technique. This technique uses the fact that $p \\rightarrow q$ is logically equivalent to (i.e. the same as) $\\neg q \\rightarrow \\neg p$. You can check this equivalence for yourself by applying the Definition of Implication to both statements and seeing that they are the same.\nThis may seem a bit unusual but it is incredibly useful to be able to rewrite a given problem in different ways and still maintain the same logical value. You can think of this as the same thing as simplifying or factoring an expression in Calculus - you get the same answer, but the manipulation to the expression makes it easier to work with.\nDefinition of Even and Odd For the example below and for other proofs you may come across it is good to explicitly know the formal definitions of even and odd numbers.\n Odd: The number can be rewritten in the form of $x = 2m + 1$, where $m \\in \\mathbb{Z}$. You can try this with any integer for $m$ and see that $x$ will always be odd. Even: The number can be rewritten in the form of $x = 2m$, where $m \\in \\mathbb{Z}$. You can try this with any integer for $m$ and see that $x$ will always be even.  Example Prove that if $n^2$ is even, then $n$ is even.\nIf you try to prove this directly, it will be quite difficult. So, we will take the contrapositive and prove it indirectly using the 2 column formal proof layout with the math on the left and the reasoning on the right.\nContrapositive: Prove that if $n$ is odd, then $n^2$ is odd.\n  Expressions Reasoning   1. $n$ is odd  Hypothesis 1   2. $n = 2p + 1$, where $p \\in \\mathbb{Z}$ ($p$ is an integer)  Definition of odd   3. $n^2 = (2p + 1)^2$  Logically/Mathematically equivalent to line 2   4. $n^2 = 2(2p^2 + 2p) + 1$  Logically/Mathematically equivalent to line 3 (multiplied the square and factored out 2)   5. $n^2 = 2k + 1$, where $k = 2p^2 + 2p$ and $k \\in \\mathbb{Z}$  Logically/Mathematically equivalent to line 4 (defined a new variable $k$ as an integer)   6. $n^2$ is odd  Logically/Mathematically equivalent to line 5 by the definition of odd   Notice how most of this proof was just applying the formal definition of odd numbers (which you already knew but not formally) and manipulating the expression until something useful came about. There is not too much to explain other than reading the proof and following along because most of it is things you already knew but just slightly more formal!\n Rules of Inference This handout will be your best friend when doing some more formal boolean algebra proofs (see the Proofs section here). Like the previous handout, I will explain one rule from this one so you know how to read and use it when you have a formal proof to solve.\nA reference chart for the rules of inference. Diagram: skedsoft.com\n  (Click here to download the image if you want to save it for safe keeping.)\nNotation in the Rules of Inference The $\\lnot$ symbol is another way is representing a negation/inversion. The $\\therefore$ symbol is called “therefore” and means therefore, you can think of it as an equal sign for now. It will make more sense in the example below. That is all the new notation in the handout! The rest should be explained in previous parts of the guide!\nRules of Inference Example I think the easiest way to understand how to use and read this chart is by making a small proof and walking you through my thought process! I will put the proof up first then explain it under.\nGiven: $(p \\land q) \\rightarrow r$, $p \\rightarrow p$, $q$. Prove $r$.\n  Expressions Reasoning   1. $(p \\land q) \\rightarrow r$  Hypothesis 1   2. $q \\rightarrow p$  Hypothesis 2   3. $q$  Hypothesis 3   4. $p$  Modus Ponens, lines 2 and 3   5. $p \\land q$  Conjunction, lines 3 and 4   6. $r$  Modus Ponens, lines 1 and 5   You are given three “hypotheses”, which are the expressions that are given to you to use to solve for $r$. You are trying to derive $r$ from these three hypotheses. I like to list out the given hypotheses first, so they are there when I want to use them later, but you can write them down you need them as you go through the proof too.\nNow to get to line 4, I look at the rules chart and I see what kind of rules I can apply to any previous lines and see if that gets me anything that can be useful. In this case, I see that Modus Ponens says if you have a line that says $p$ and a line that says $p \\rightarrow q$, you can get $q$ as a result. I know the letters are a bit off but that is okay as long as you keep it consistent, you can make a substitution, so you can temporarily think of the $p$ in the proof as the $q$ in the chart and vice versa.\nThe logic behind Modus Ponens applied to line 4 is that if you have the value of $q$ in line 3 and you have the expression that says $q$ implies the value of $p$, then you can use $q$ you have to get the value of $p$. I think of this one as “unlocking”. I need to get a $q$ because I have something that tells me that $q$ “unlocks” a new value that I need, which is $p$.\nPut into a more concrete example, let’s say $q =$ it is raining and $p =$ get an umbrella. Then you have a line that says $q \\rightarrow p$ (i.e “if it is raining, then get an umbrella). You can observe that is raining, so we have established $q$ to be True (which is what line 3 represents in the proof). We have a statement (the implication arrow) that says what to do if it is raining, so we can conclude $p$ from that, which is to get an umbrella.\nIn line 5 of the proof, this is using the Conjunction rule, which allows you to combine any expressions in the proof so far with an AND ($\\land$) between them. In this case, I see that it would helpful to do that because Hypothesis 1 on line says that if you have $p \\land q$, you can get $r$, which is what we need.\nFinally, I apply Modus Ponens again to lines 1 and 5 to get $r$ from $p \\land q$ and $(p \\land q) \\rightarrow r$.\n Induction Induction is usually the proof technique that is hardest to grasp in my experience working with students, but it gets easier with more practice problems.\nThe easiest introduction to the concept here is to think of a staircase. In order to begin walking on the staircase to get to each next step, you must first get on the very first step, but when you get on the first step, you know know how to get to the next step. So you use that information to get you to each next step until you get to the end.\nIn inductive proofs, it is a similar flow: the first “step in the stair case” is a mathematical expression that must be established as true. Then you use that proven statement to help you prove each next step.\nThere are two types of induction: weak and strong.\nWeak Induction Putting the staircase analogy formally, $p(n) \\rightarrow p(n+1)$, where $n \\in \\mathbb{N}$.\n","categories":"","description":"Introduction to Proofs.\n","excerpt":"Introduction to Proofs.\n","ref":"/ucsc-guide/docs/majorguides/computerscience/discretemath/proofs/","tags":"","title":"Proofs"},{"body":"","categories":"","description":"An explanation of how to add, commit, and push files.","excerpt":"An explanation of how to add, commit, and push files.","ref":"/ucsc-guide/docs/majorguides/computerscience/git/basics/basic_git_operations/","tags":"","title":"Basic Git Operations"},{"body":"","categories":"","description":"An explanation of version control and how it pertains to Git.","excerpt":"An explanation of version control and how it pertains to Git.","ref":"/ucsc-guide/docs/majorguides/computerscience/git/fundamentals/what_is_version_control/","tags":"","title":"What Is Version Control?"},{"body":"The knowledge you gain about logic from Discrete Math (CSE 16) and Computer Systems and Assembly Language (CSE 12) will be some of the most commonly used skills in your career because of how frequently we use conditional statements and try to simplify them in code.\nDefinitions  Bit: a bit is a binary value that is a 0 or a 1. Just one, not both, and nothing in between. Binary: a number system used in computer science that has only the numbers 0 and 1. Boolean: only has the value of True or False. Just one, not both, and nothing in between. Proposition: a logical expression that can be evalutated to a True or False value.  Logic Gates This is one of the most common concepts you will come across when doing any programming. So, you will eventually memorize these, if you have not seen them before just from how often you will need to use them. All of the following gates are boolean/binary operations, which means that the inputs and outputs can only be True (1) or False (0) and nothing else and nothing in between.\n AND The AND gate can take in any number of input greater than 1. The truth table for the AND gate and its appearance in digital logic design is shown below.\nIn short, the AND gate returns/outputs a True (1), only when all of its inputs are True (1). It returns/outputs a False (0) otherwise (i.e. when at least one input is False (0) ).\n  Example: You want to check if A AND B AND C AND D are all True (1).\n  Example: You are making a new social media and working on how to have a user create a new account. You need to check if the user entered a valid email AND they are over a certain age AND entered a secure password.\n   OR The OR gate can take in any number of input greater than 1. The truth table for the OR gate and its appearance in digital logic design is shown below.\nIn short, the OR gate returns/outputs a True (1), when at least one of its inputs are True (1). The other inputs can be anything else - there just has to be at least one True (1) in the inputs. It returns/outputs False (0) when all of the inputs are False (0).\n  Example: You want to check if any one of A OR B OR C OR D are True (1).\n  Example: You are making a scheduler. You want to check if the timer for the current task at hand has run out OR if the current task has finished so you can move on to another task. (This is one algorithm that a CPU may use schedule tasks in your computer!)\n   NOT The NOT gate (also called an inverter) can take in 1 input and invert it. The truth table for the NOT gate and its appearance in digital logic design is shown below.\nIn short, if the input is a True (1), then the output is a False (0). If the input is a False (0), then the output is a True (1).\n  Example: You want to invert the truth value of one variable A.\n  Example: You are making a game and want to check when the player in the game is alive or dead so you know to continue the game or display the “game over” message. You make a conditional statement to continue running the game while the player is NOT dead.\n   XOR The XOR gate can take any number of input greater than 1. The truth table for the XOR gate and its appearance in digital logic design is shown below. XOR stands for “exclusive or”, so one or the other but not both. The use of a XOR gate is not as common as the previous gates, but it still comes up and good to know.\nIn short, the XOR gate returns/outputs a True (1), if only 1 of the inputs is True (1) and False (0) otherwise.\n Example: A server sends 4 bits to a client and calculates the XOR of the 4 bits and the result is 1 and appends this resulting bit to the 4 (now 5) bit message to the client. The client can XOR the first 4 bits and if the result of the XOR is not the same as what the 5th bit says, then the message has been corrupted in transmission. But this is not a complete check since the message can be corrupted in a way that the server and client XOR results still line up.   Opposite Gates Each one of the gates above have one that is the opposite as what it is normally. The AND gate has its opposite called NAND gate. OR has NOR. NOT/NO has BUFFER/YES. XOR has XNOR. The truth tables and digital logic design for all of these gates are also below. Essentially, just take the outputs of the normal gate and invert them and that is the truth table for the corresponding opposite gate.\n Truth Tables Truth tables can be tedious to make if there are a lot of inputs, but it is one of the most effective ways to visualize a problem. Similar to how Venn Diagrams are useful to help understand some set theory problems, truth tables are an excellent way to check if two statements are equivalent or not or simply evaluate an expression to see its resulting truth value.\nHere is the visual for all of the logic gates described above. Now let us see how to read it.\nA visual guide to the common logic gates. Diagram: Proprofs.com\n  (Click here to download the image if you want to save it for safe keeping.)\nThe $A$ and $B$ on the left columns are example inputs to the gate. Remember these can only be boolean/binary True (1)/False (0). They can the results of previously evaluated expression or a simple 1 or 0 as you see in the tables.\n Notice that the inputs start at all 0 and then slowly work their way to all 1 at the bottom and that all of these rows make up every single possible combination of inputs that this gate have take. These are only 2 input gates, but you can come up with the tables for more inputs or Google them.\n Now, look at the table one row at a time. Those two inputs get that gate operation applied to them and then the result is in the right side column.\n Laws of Logic This handout will be your best friend when working with logical expressions/equations that you need to evaluate or simplify. I will explain one rule on the handout so you know how to read and use it.\nA reference chart for the laws of logic. Diagram: math.stackexchange.com\n  (Click here to download the image if you want to save it for safe keeping.)\nNotation in the Logic Laws The T and F stand for True and False, respectively. The $p$, $q$, and $r$ used in the diagram are just variables that have boolean values. They can stand for a single variable in an equation or a piece of an expression (ex. $p$ can just be a variable in the equation as $p$ itself like how you can have $x$ in an expression in Calculus OR it can be representative for something bigger than a single variable like how you can have $x = (a + b/2)$ in Calculus). The $\\equiv$ symbol means “logically equivalent” (i.e. equal to). The $\\rightarrow$ symbol is called “the arrow of implication” read in an expression as “implies”. So $p \\rightarrow q$ is read aloud as “$p$ implies $q$”.\n Note: The first one in Table 7 is called “Definition of Implication” and the first one in Table 8 is called “Definition of Equivalence/Biconditional”.\n  Duals Most of the logic laws have everything the same in their equations but the $\\lor$ and $\\land$ signs are flipped ($\\lor$ becomes $\\land$ and $\\land$ becomes $\\lor$). This operation of switching the ANDs and ORs is called “taking the dual”. In other words, one of these laws is the dual of the other (with the same name).\n Note: The Double Negation, Defintion of Implication, and Definition of Equivalence do not have any duals.\n  Logic Law Handout Example Let us take a look at the Commutative Laws. Notice how there are two Commutative Laws.\nFor the first Commutative Law, it says (in English): “the (truth) value of $p$ OR’ed with the (truth) value of $q$ is logically equivalent to the (truth) value of $q$ OR’ed with the (truth) value of $p$”. Notice how this is the same exact thing that you have seen before in previous math classes: $x + y = y + x$… same thing!\n ","categories":"","description":"Introduction to Logic.\n","excerpt":"Introduction to Logic.\n","ref":"/ucsc-guide/docs/majorguides/computerscience/discretemath/logic/","tags":"","title":"Logic"},{"body":"As a UCSC student, the concepts and skills from this lower division class are absolutely essential. The material from Discrete Math shows up many times in upper division courses many times, so it is well worth your time to understand as much as you can from this class now, so later classes are not as challenging as they could be.\n","categories":"","description":"Introduction to Logic, Set Theory, and Proofs.\n","excerpt":"Introduction to Logic, Set Theory, and Proofs.\n","ref":"/ucsc-guide/docs/majorguides/computerscience/discretemath/","tags":"","title":"Discrete Math"},{"body":"Set theory is the branch of mathematical logic that studies sets, which can be informally described as collections of objects. Founded by German mathematicians Richard Dedekind and Georg Cantor in the 1870s (Wikipedia).\nDefinitions Set A collection of objects, where order and repetition does not matter. Sets can hold any type of objects, not strictly 1 character numbers or letters.\nSet Notation Sets are usually surrounded by curly braces with commas separating elements and when assigned to a variable, the convention is to use a single capital letter (although there may be exceptions).\nElement The objects inside a set.\nElement Notation When you want to note a specific element from a set, you use the $\\in$ symbol. When an element is not in a set, you use the $\\notin$ symbol.\n Example: Written as $1 \\in A$. Read/Spoken as “1 is an element of (set) A” OR “1 is a member of (set) A”. Example: Written as $34 \\notin A$. Read/Spoken as “34 is not an element of (set) A” OR “34 is not a member of (set) A”.  Examples $A = \\{1, 2, 3, 4\\}$. $B = \\{a, b, c, d\\}$. $C = \\{cat, dog, cow, fox\\}$.\n Note: If you see “$\\dots$” in a set that means that it should be clear what elements come next infinitely (i.e. this is the pattern for the set and it does not end).\n  Common Sets These are special sets that are used across mathematics and computer science theory (algorithms).\nReal numbers  This set has any decimal number of any precision. Symbol: $\\mathbb{R}$ Examples: 1.0, 388.09384, 3.1415, -1005.6400009  Natural numbers  This set has the counting numbers that you use everyday. Depending on context, they may start with 0 or 1, so be careful. Symbol: $\\mathbb{N}$ Example: $\\{0, 1, 2, 3, 4, \\dots\\}$  Integers  This set has any positive or negative whole number. Symbol: $\\mathbb{Z}$ Example: $\\{\\dots, -3, -2, -1, 0, 1, 2, 3, \\dots\\}$  Rational numbers  This set has the result of dividing any two integers, but not 0 in the deminator. Symbol: $\\mathbb{Q}$ Examples: $\\frac{3}{2}, \\frac{2}{4}, \\frac{-24}{97}$  Empty set  This is the set that has no elements in it. Symbol: $\\emptyset$ OR $\\{\\}$   Cardinality Defintion The size/length of the set.\nNotation Vertical bars around the name of the set.\nExamples  Let $A = \\{1, 2, 3, 4\\}$. The cardinality of set $A = |A| = 4$. Let $B = \\{A, D, G, N, I, Y\\}$. The cardinality of set $B = |B| = 6$.  Some sets are considered countable and some are considered uncountable. Simply, a set is countable if you can use the natural numbers to count the set in question. A set is uncountable if you cannout use the natural numbers to count it. There are also finite and infinite sets. A set is infinite is it has infinitely many elements and finite if it has a finite number of elements.\n Subsets Definition One set is a subset of another if all of the elements of one set can be found in the other.\nNotation $A \\subset B$ OR $A \\subseteq B$. The “$\\subset$” symbol is called “proper subset” and the “$\\subseteq$” is called “subset”.\n Note: There is a little line under the symbol in the second example. This subtle difference between the two symbols is similar to $\u003c$ and $\\le$.\n Example of proper subset Let $A = \\{1, 2, 3, 4\\}$ and let $B = \\{1, 2, 3, 4, 5, 6, 7, 8\\}$. In this case, $A \\subset B$ because all of the elements in set $A$ can be found in set $B$, but $B$ has some elements that $A$ does not. That is how it is written, but when it is read/spoken, you say “(set) $A$ is a proper subset of (set) $B$”.\nExample of subset Let $A = \\{1, 2, 3, 4\\}$ and let $B = \\{1, 2, 3, 4\\}$. In this case, $A \\subseteq B$ because all of the elements in set $A$ can be found in set $B$ and the two sets happen to be the same set. That is how it is written, but when it is read/spoken, you say “(set) $A$ is a subset of (set) $B$”.\nVisually A visual example of subsets and proper subsets Photo: OnlineMathLearning.com\n  (Click here to download the image if you want to save it for safe keeping.)\n Note: The $U$ in the top left corner stands for the “universive of discourse”. You can think of this as the “domain” of the problem, where the universe has all possible values in a given problem.\n  Power Set Definition A power set of a set is the set of all possible subsets that can be made from the original set.\nNotation $\\mathcal{P}(A)$\nExample Let $A = \\{1, 2, 3\\}$. $\\mathcal{P}(A) = { {}, {1}, {2}, {3}, {1, 2}, {1, 3}, {2, 3}, {1, 2, 3} }$.\n Note: A quick check to make sure you didn’t miss a set when making the power set is to count the number of sets in your power set and see if it equals $2^{|A|}$. But this isn’t a complete/exhaustive check, so make sure you get every combination.\n  Note: The empty set is a subset of any set and therfore in every power set.\n  Common Set/Logic Operations You can perform operations on sets. These operations are fairly common in discete math, algorithms, and logic/hardware. Some of the styles of notation may differ across these fields, but they all mean the same.\nUnion/OR This operation is similar to an “addition” of the sets involved, like a combination. Combine the sets involved into one big set, but no duplicates. In set theory it is called “union” and in logic/hardware it is called “OR”.\nNotation Set theory: $A \\cup B$. Logic/hardware: $A \\lor B$.\nExample Let $A = \\{1, 2, 3\\}$ and let $B = \\{3, 4, 5, 6\\}$. The union of sets $A$ and $B$ is $\\{1, 2, 3, 4, 5, 6\\}$.\n Intersection/AND This operation is finding the commonalities bewtween the sets involved. In set theory it is called “intersection” and in logic/hardware it is called “AND”.\nNotation Set theory: $A \\cap B$. Logic/hardware: $A \\land B$.\nExample Let $A = \\{1, 2, 3\\}$ and let $B = \\{3, 4, 5, 1\\}$. The intersection of set $A$ and $B$ is $\\{1, 3\\}$.\n Complement/NOT In set theory, this operation is finding what is not in the set in question, but in logic/hardware, this operation is taking the opposite of a True/False value. This operation can be done in addition to other operations on one or more sets. It is also called a “negation”.\nNotation Set theory: $A^C$. Logic/hardware: $\\bar{A}$ or $A'$, or $\\sim A$.\nExamples Let the universe $U = \\{1, 2, 3, 4, 5, 6\\}$. Let $A = \\{1, 2, 3\\}$. Let $B = \\{3, 4, 5, 1\\}$.\n $A^C = \\{4, 5, 6\\}$ $\\overline{A \\cup B} = \\{6\\}$   Note: In the last example, I used a very famous law/rule called DeMorgan’s Law, which will be left up to you to Google (very simple, but incredibly powerful trick). In short, DeMorgan’s Law lets you move a negation in and out of parantheses while maintaining the correctness of the answer.\n Visually A visual example of subsets and proper subsets Photo: OnlineMathLearning.com\n  (Click here to download the image if you want to save it for safe keeping.)\n Note: Venn Diagrams are incredibly useful to visualize some of the set operations in more complicated problems that involve more than 2 simple, small sets. So if you are having trouble wrapping your head around a problem or operation when solving a problem, draw it out!\n ","categories":"","description":"Introduction to Set Theory.\n","excerpt":"Introduction to Set Theory.\n","ref":"/ucsc-guide/docs/majorguides/computerscience/discretemath/settheory/","tags":"","title":"Set Theory"},{"body":"","categories":"","description":"Your guide to lower divsion computer science courses and concepts at UCSC.\n","excerpt":"Your guide to lower divsion computer science courses and concepts at …","ref":"/ucsc-guide/docs/majorguides/computerscience/","tags":"","title":"Computer Science"},{"body":"I got a house close to the base of campus in Summer 2020 and this is an approximate sequence of events and resources I found (but not necessarily used) to help get a place to live.\n Picking Your Group UCSC Community Rentals - Before You Rent\nThe most important thing I would do before even starting to look for a house is to find a solid group of people to live with. Personally, I think a group of 3 - 5 people is a great middle ground for house cleanliness and fun but also somewhat private and quiet to study. Make sure you talk about everyone’s preferences, living condition/way of living, and price ranges. It is very competitive to find housing in Santa Cruz, so you want to pick a solid group who can communicate and be ready to apply to maximize chances of getting the house. You should be doing this around February.\n Starting Your Search After you have your group picked out, have everyone in the group start searching any and all websites for house listings that match the group’s preferences, while simulateously filling out a renter’s application packet. Some landlords ask for it and some don’t, but it takes a little while to put together, so start early. See the link above for more information on it. This also the time to take the quick Canvas Renter’s Workshop. Some landlords ask that you complete it and show the certificate of completion (mine did), but even if they don’t ask, there is still some good information in there about off campus housing in general. You should be doing this in February - March.\n Links for Your Search Here is a list of sites to search for (in no particular order, not exhaustive):\n Zillow (this is where I found my house) Apartments.com Realtor.com Craigslist Santa Cruz Housing Facebook Public Group UCSC Housing, Sublets \u0026 Roommates Facebook Private Group University of California, Santa Cruz (UCSC) Housing, Sublets \u0026 Roommates Facebook Private Group   Contacting Potential Landlords Keep searching all the sites you can and when you reach out to landlord via email or text (however they prefer), I would recommend only having one person communicating with the landlord and then they will convey the updates to the rest of the group - it is usually much more oragnized and less confusing to keep track of who is talking to who. You should be doing this starting in March - April.\nWhen you first contact a landlord to express interest in their listing, I recommend you do the following:\n quickly introduce yourself and your group - names, majors, year express interest in that specific listing - give the address of the place so they know which one in case they have more than one try to sell yourself and your group a little - make yourselves sound like good tenants (and make sure that is the reality too) ask about availability for a tour, applying, and signing the lease so they can get a feel that you are serious about securing this house.  Keep this initial email/text with the landlord SHORT. Get to the point - housing is competitive in Santa Cruz, so you don’t want to deter landlords with a long essay. Make it easier for them.\n Note: This process of searching for potential houses and contacting landlords usually takes a while, so be patient and keep searching. Many landlords will ghost you, leave you on read, or take a while to reply. Don’t take it personal and just move on to the next.\n Pay attention to the date the house is available for new tenants if it is mentioned in the listing online. If it isn’t online you can ask about it in the initial email, but it will be in the lease. I prefer a start date/time that is anytime outside the school year in case my group doesn’t want to resign for another year or we get kicked out, we won’t be doing this whole process again while taking classes. Most leases are 12 months long, so you will be paying for the summer months rent anyway, but you can ask for a month to month lease or a term shorter than 12 months (although landlords do not prefer this).\n Reading the Lease After engaging in talks with landlord and you seem to have a place that will be yours, the landlord will send you the lease and give you a little bit of time to read and sign it. Please read the lease completely.\n Note: Look for contradictions, unfair rules, things that stand out or don’t make sense, and ask for clarification. Make sure you, your group, and the landlord are all in agreement about the terms of the lease BEFORE signing. If you don’t read the whole thing, then at the very least, read the first couple pages since that is where the main points are usually.\n  Move In and Things to Set Up Next is to pay your (refundable) safety deposit, get the keys, and move in! Congratulations! Some houses are prefunished, but I would say most are not. So figure out if anything comes with the house and fill in the missing furniture or appliances with your group.\nRead the terms of your lease to remember what utilities (PG\u0026E, water, trash, cable/internet) you are and not responsible for paying and get those set up. I would say that usually one person takes responsiblilty to pay for one utility to make it fair and everyone pays them back.\n Note: start setting up the utilities (especially internet) as soon as you get the keys to make sure you have a smooth start.\n Be a good housemate, roommate, neighbor, and tenant. It isn’t technically your house, but you should be treating as if it is (or risk losing a lot of your safety deposit)!\n More resources  Community Rentals - (ucsc site) has many more links and resources to help Places4Students - place to find rentals and housemates Legal Services \u0026 Consulation - free access to an attorney for UCSC students if you have legal concerns regarding off campus housing (offered via UCSC Dean of Students) Community Rentals - Questions to Ask - questions to ask the landlord  ","categories":"","description":"How and when to secure a house or apartment off campus.\n","excerpt":"How and when to secure a house or apartment off campus.\n","ref":"/ucsc-guide/docs/housing/offcampus/house_apartment/","tags":"","title":"House/Apartment"},{"body":"","categories":"","description":"Introduction to Machine Learning at UCSC (CSE 144).\n","excerpt":"Introduction to Machine Learning at UCSC (CSE 144).\n","ref":"/ucsc-guide/docs/majorguides/computerscience/machinelearning/","tags":"","title":"Intro to Machine Learning"},{"body":"Hello! Welcome to UCSC and the Unofficial UCSC Student Guide. Congratulations on your admission to UC Santa Cruz!\nFor new/prospective students This guide’s purpose is to introduce new students to UCSC student life through tips and experiences shared from experienced, fellow UCSC peers. It seems that many UCSC sites are hard to navigate and not incredibly informative since they lack student opinions, so this guide will complement much of the important information from the UCSC sites with student perspectives and thoughts to give new students a more realistic and holistic introduction to UCSC.\n For current/returning students Some of the information in the Guide may already be known to you and some of it may not. If you find something to be inaccurate or would like to add more information, please let me know or see the Contribution Guidelines if you would like to try making a fix yourself!\n Site navigation and use There is a navigation bar on the left-hand side that will categorize all the different sections of the Guide, ranging from off campus housing to preparation for your major studies to student employment. Relevant links from UCSC sites and other official sources will be put as much as possible throughout the Guide so you can always trace back this summarized information to the source to verify its authenticity.\nThe right side of each page will have links to the different subsections of that page for easy access to particular information you are looking for or just to act as a summary of what the current page has.\nThe bottom of each page will have a link to the next section if you want to read and click through in order, but you can pick and choose any section from the navigation bar. The time the site was last updated will also be on the bottom of each page, so you know how up-to-date the information is.\nWe will try to put up as many preparation guide for as many majors as we can, but most of our contributors are computer science majors, so our expertise in other fields are not good enough to know how to make an appropriate guide for other programs of study. For these other majors, we will contact other students and department advising offices to put something together. This will be something along the lines of a “Things I wish I knew before starting [Your Major] at UCSC”.\nThere will also be more general UCSC student information in addition to specific majors and programs, such as info on dining halls, on/off campus housing, residential colleges, and financial aid guides.\n Disclaimer This guide is in no way affiliated with UC Santa Cruz, the Regents of the University of California, or the University of California. It is an unofficial guide put together by UCSC students.\n","categories":"","description":"Start your journey through the Guide here.\n","excerpt":"Start your journey through the Guide here.\n","ref":"/ucsc-guide/docs/","tags":"","title":"How to Use This Guide"},{"body":"","categories":"","description":"Off campus, but through UCSC housing in downtown Santa Cruz.\n","excerpt":"Off campus, but through UCSC housing in downtown Santa Cruz.\n","ref":"/ucsc-guide/docs/housing/offcampus/utc/","tags":"","title":"University Town Center"},{"body":"","categories":"","description":"An explanation on what exactly Git is.","excerpt":"An explanation on what exactly Git is.","ref":"/ucsc-guide/docs/majorguides/computerscience/git/fundamentals/how_git_works/","tags":"","title":"How Git Works"},{"body":"","categories":"","description":"Your guide to on and off campus housing.\n","excerpt":"Your guide to on and off campus housing.\n","ref":"/ucsc-guide/docs/housing/","tags":"","title":"Housing"},{"body":"","categories":"","description":"Your guide to each major at UCSC.\n","excerpt":"Your guide to each major at UCSC.\n","ref":"/ucsc-guide/docs/majorguides/","tags":"","title":"Major Guides"},{"body":"","categories":"","description":"Your guide to off campus housing.\n","excerpt":"Your guide to off campus housing.\n","ref":"/ucsc-guide/docs/housing/offcampus/","tags":"","title":"Off Campus Housing"},{"body":"The ten colleges are listed below in order of when they were founded from first to most recent. Applications for on-campus housing for the following school year open in Spring Quarter. There is a priority application and a regular application period. On-campus housing usually very competitive and based on a point system. You acquire more points by seniority and housing with people from the same college affiliation.\n","categories":"","description":"Your guide to on campus housing.\n","excerpt":"Your guide to on campus housing.\n","ref":"/ucsc-guide/docs/housing/oncampus/","tags":"","title":"On Campus Housing"},{"body":"Hello and thank you for wanting to contribute to the project! All experience levels are welcome! Please take a look at HELPWANTED.md to see items that are outside of the current team’s expertise that need help to expand the scope of the project.\nThe Unofficial UCSC Student Guide is an open source project and welcome to patches, contributions, and improvements!\nThe Guide lives on GitHub. You can view all of its source code there.\n For those inexperienced with programming: Create an issue If there’s something you’d like to see in The Guide (or if you’ve found something that isn’t working the way you’d expect), but you’re not sure how to fix it yourself, please create an issue or contact Hilal via email (hamorrar@ucsc.edu) or Discord (hmorrar#1632).\n For those experienced with programming: Initial setup The guide uses the extended version of hugo with the Docsy theme.\n Install Git. Install Node (and its dependencies if on Windows). Download and install the extended version of Hugo (linked above). You can also use snap to install the extended version of Hugo with sudo snap install hugo --channel=extended. snap works with a lot of Linux distros, and is pre-installed with some major distros such as Ubuntu 16.04+. Fork the repository on GitHub. Use the recursive tag when cloning your fork so that all the submodules are also downloaded: git clone --recursive git@github.com:your-username/ucsc-guide.git cd ucsc-guide to navigate into the project. Install all the dependencies: npm install. Use the hugo serve or hugo server command to start the server. If you would like to expose the website to your network, use hugo serve --bind 0.0.0.0 or hugo server --bind 0.0.0.0. This is useful for accessing the site from another machine when you are using a GUI-less OS to run the site. Open a browser and go to https://localhost:1313/ucsc-guide.  Notes for Hugo development The repository looks a bit intimidating at first, but most of it is all set up from Hugo initially. Most of the work will be done in the /content/en/docs directory to write up articles in Markdown. When previewing changes locally, be careful of the draft value in the top of the Markdown file you are working in. If it is set to true, it will not show up in the final build, but it will show up in a preview only if you use the -D flag in when starting the local server. Every article page you want to write has to have those preamble lines (Hugo calls it “front matter”) at the top for it to render correctly (or at all). You can copy and paste from another file and modify the appropriate fields.\n title is the title of the article linkTitle is what will show up in the left navigation bar author is the author of the article date is the date the article was written in YYYY-MM-DD format weight is for ordering the pages in the directory for the left navigation bar icon is if you want to put an emote next to the title in the left navigation bar from Font Awesome draft is to publish the file on the site if it is in the main branch (false - not a draft. true - is a draft) description is a quick one line summary/preview/subtitle for the article to display under the main title on the page  Create a pull request and preview locally Continue with the usual GitHub workflow to edit files, commit them, push the changes up to your fork, and create a pull request. For more general information on how to contribute to open source projects, check out Open Source Guides. Please follow similar writing style in new contributions.\nSteps to contribute:\n Fork the repository. Clone your fork to your machine. Create or checkout an/the appropriate branch. Commit your changes. Push to your fork of the repo. Make a Pull Request for review.  Conventions When creating or editing pages, we follow certain conventions to ensure consistency across the codebase and articles. These conventions are listed below.\nConventions:\n Folders and subfolders within /content/en/docs are to be PascalCase. Files within /content/en/docs and its subfolders are to be snake_case. An exception to this convention is index files. Index files should be named _index.md. Article titles are to be Title Case. Article subheadings are to be Sentence case. Commit messages are to be descriptive. They must describe the commit accurately and concisely.  Code reviews Submissions will be reviewed by at least one person (Hilal). We use GitHub pull requests for this purpose. Consult GitHub Help for more information on using pull requests.\n Code of conduct This project follows the Contributor Covenant Code of Conduct.\nLicense By contributing, you agree that your contributions will be licensed under the GNU General Public License v3.0 license.\n","categories":"","description":"How to contribute to the Unofficial UCSC Student Guide.\n","excerpt":"How to contribute to the Unofficial UCSC Student Guide.\n","ref":"/ucsc-guide/docs/contribution_guidelines/","tags":"","title":"Contribution Guidelines"},{"body":"","categories":"","description":"A guide for the basics of Git.","excerpt":"A guide for the basics of Git.","ref":"/ucsc-guide/docs/majorguides/computerscience/git/basics/","tags":"","title":"Git Basics"},{"body":"","categories":"","description":"A guide for how Git works.","excerpt":"A guide for how Git works.","ref":"/ucsc-guide/docs/majorguides/computerscience/git/fundamentals/","tags":"","title":"Git Fundamentals"},{"body":"","categories":"","description":"A tutorial for Git","excerpt":"A tutorial for Git","ref":"/ucsc-guide/docs/majorguides/computerscience/git/","tags":"","title":"Git"},{"body":"","categories":"","description":"","excerpt":"","ref":"/ucsc-guide/categories/","tags":"","title":"Categories"},{"body":"","categories":"","description":"","excerpt":"","ref":"/ucsc-guide/tags/","tags":"","title":"Tags"},{"body":"  #td-cover-block-0 { background-image: url(/ucsc-guide/slug-background_hu07d0d2c1dee64a58563c07828b576f50_918235_960x540_fill_q75_catmullrom_top.jpg); } @media only screen and (min-width: 1200px) { #td-cover-block-0 { background-image: url(/ucsc-guide/slug-background_hu07d0d2c1dee64a58563c07828b576f50_918235_1920x1080_fill_q75_catmullrom_top.jpg); } }  Welcome to the Unofficial UCSC Student Guide! Get Started   Contribute   A (semi-comprehensive, work in progress) guide for UCSC students.\n         The Unofficial UCSC Student Guide is made for UCSC students, by UCSC students. The purpose of this guide is provide quick and easily accessible resources and information for most student concerns by making a single site that has everything you need to know to succeed at UCSC.\n      Searchable site!  Use the search bar in the top right corner to search the documentation or click the Get Started button to view the guide.\n   Contributions welcome!  We do a Pull Request contributions workflow on GitHub. If you are new to contributing, do not fear, check out the contribution guidelines!\nRead more …\n   For UCSC students, by UCSC students!  This guide is composed of articles written by several contributors. We are always looking to improve the information in this guide and hope that you will help out where you can!\n    ","categories":"","description":"","excerpt":"  #td-cover-block-0 { background-image: …","ref":"/ucsc-guide/","tags":"","title":"Unofficial UCSC Student Guide"}]