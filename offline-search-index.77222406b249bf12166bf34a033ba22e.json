
























[{"body":"Prerequisites   Compile with debug symbols. To do this, add the -g flag when you compile. For example, clang -g -o program.o program.c. For convenience, add a target to your makefile, i.e.:\ndebug: CFLAGS += -g debug: all   Launch GDB using ./gdb --args followed by the your normal method of execution. For example, for a program named program and one flag –flag, run gdb --args ./program --flags.\n  Once inside GDB, the command run will run your program.\n  Finding Segmentation Faults First, run your program using GDB. When your program crashes, you should see the exact line on which your program failed.\nFor more information, use the backtrace command. The stack trace should show the path your program took during its execution. For example, if your program crashes in the standard library’s strlen function, there won’t be much information there. Running backtrace will show you the arguments passed to the function and which function called strlen.\nExample $ gdb --args ./executable Reading symbols from ./executable... GDB has read the executable. The (gdb) prompt means anything typed is sent to GDB, not to the shell.\n(gdb) run Starting program: /path/to/executable Program received signal SIGSEGV, Segmentation fault. 0x000055555555512c in my_function (array=0x0) at ./segfault.c:4 4 return array[0]; The program received a segmentation fault in the function my_function. The function has one argument, array=0x0 (i.e., NULL).This is the source of the segmentation fault, since the code is attempting to access the 0th element of NULL memory.\n(gdb) backtrace #0 0x000055555555512c in my_function (array=0x0) at ./segfault.c:4 #1 0x0000555555555150 in main () at ./segfault.c:9 (gdb) The function my_function was called from the function main.\n","categories":"","description":"Debugging with GDB to identify segmentation faults.","excerpt":"Debugging with GDB to identify segmentation faults.","ref":"/ucsc-guide/docs/majorguides/computerscience/cprogramming/gdb/","tags":"","title":"Debugging with GDB"},{"body":"This page describes how to compile C programs that are more complex than a single source file. We’ll cover how to split code across multiple files, how to compile those files, how to automate the build process using GNU Make, and how to make use of system libraries.\nYou can follow along with this guide on your own computer. All you’ll need is familiarity with the command line and a C programming environment with recent versions of Clang and Make. I would recommend using Linux (either running on your computer, in a virtual machine, or in WSL2). These commands may also work on macOS if you install Clang and Make, but they will not work on Windows if you don’t have a Linux environment.\nOur program To get started, create an empty directory to hold all the files that we create. The name doesn’t matter. Navigate into that directory and create the following C file called hypot.c. This is the program that we will be working with. Given two side lengths of a right triangle, it calculates the length of the hypotenuse.\n// hypot.c #include \u003cstdio.h\u003e#include \u003cstdlib.h\u003e // approximation of sqrt(x) for some values of x unsigned int sqrts[] = { 0, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, }; unsigned int my_sqrt(unsigned int x) { if (x \u003e 25) { fprintf(stderr, \"error: cannot take sqrt of %u\\n\", x); exit(2); } return sqrts[x]; } double my_hypot(double a, double b) { return my_sqrt(a * a + b * b); } int main(void) { double a, b; printf(\"side a: \"); if (!scanf(\"%lf\", \u0026a)) { fprintf(stderr, \"invalid input\\n\"); return 1; } printf(\"side b: \"); if (!scanf(\"%lf\", \u0026b)) { fprintf(stderr, \"invalid input\\n\"); return 1; } printf(\"c = %lf\\n\", my_hypot(a, b)); return 0; } You may already know the command to compile this using Clang:\n$ clang -Wall -Werror -Wextra -Wpedantic -o hypot hypot.c But what does every part of this mean? Clang, like most command line programs, lets you specify input files (in this case, C files to compile) as well as flags that modify its behavior. Each argument that isn’t part of a flag is interpreted as an input file. Let’s break down all the arguments:\n -Wall, -Werror, -Wextra, -Wpedantic: each of these enables a certain class of warnings. Together, they make Clang very strict. With these flags, compilation will often fail when issues are encountered that would normally only be treated as warnings. -o, hypot: the o stands for “output,” and means that the next argument should be used as the output filename. This makes Clang save the executable file as hypot, and prevents hypot from being interpreted as an input filename. hypot.c: this is the only input file.  The compilation should succeed without errors. Now you can run the program:\n$ ./hypot side a: 3 side b: 4 c = 5.000000 It worked! But, as you might have noticed from the code, our calculation is extremely limited—the square root function only returns integer approximations for numbers between 0 and 25, and fails on any other numbers. Here’s an example:\n$ ./hypot side a: 2 side b: 2 c = 3.000000 The side length should be √8 ≈ 2.828. We’re going to modify this program to:\n use the built-in math library’s sqrt function move the my_hypot function into another file automatically compile with all the right parameters when we run make  Using the math library You may know that in order to call math functions like sqrt, you need to do two things: put #include \u003cmath.h\u003e at the top of your file, and add -lm to your compilation flags. What do these do?\nHeader files Including a file with #include inserts its contents at the position of the #include statement, nothing more. Since \u003cmath.h\u003e uses angle brackets instead of quotes, the preprocessor (which is responsible for processing includes, among other things) looks for a file in the include path, instead of the current directory. You can modify the include path, but the default (on Linux, at least) is /usr/include. This means that we are including /usr/include/math.h, a file that comes with the operating system. You can actually open and view this file! Sadly, it is full of macros and includes other files, so the actual declaration of sqrt is not easy to find, but you can imagine that somewhere in that file is the declaration:\ndouble sqrt(double x); (Since the preprocessor processes includes recursively, as far as you are concerned, that declaration may as well actually be in /usr/include/math.h. The fact that it isn’t is transparent to you.)\nLet’s change our program to use the system’s sqrt function (to make this tutorial easier to follow, when you modify a file, I’ll specify what the complete contents should now be):\n// hypot.c #include \u003cstdio.h\u003e#include \u003cstdlib.h\u003e// new line #include \u003cmath.h\u003e // deleted: sqrts array and my_sqrt function  double my_hypot(double a, double b) { // modified  return sqrt(a * a + b * b); } int main(void) { double a, b; printf(\"side a: \"); if (!scanf(\"%lf\", \u0026a)) { fprintf(stderr, \"invalid input\\n\"); return 1; } printf(\"side b: \"); if (!scanf(\"%lf\", \u0026b)) { fprintf(stderr, \"invalid input\\n\"); return 1; } printf(\"c = %lf\\n\", my_hypot(a, b)); return 0; } Linking against a system library Let’s recompile:\n$ clang -Wall -Wextra -Werror -Wpedantic hypot.c -o hypot /usr/bin/ld: /tmp/hypot-1e886c.o: in function `my_hypot': hypot.c:(.text+0x2b): undefined reference to `sqrt' clang-12: error: linker command failed with exit code 1 (use -v to see invocation) Uh oh! The important part of this error is undefined reference to `sqrt'. Remember that math.h contains only the declaration of sqrt. That essentially tells the compiler that there will be a function available, called sqrt, returning a double, and taking one double as its argument. However, to finish linking the binary, the linker needs to know what the address of that function will be at runtime, so that it can insert the proper function call. (We’ll get into the difference between compiling and linking later. For now, know that clang -Wall -Wextra -Werror -Wpedantic hypot.c -o hypot runs both steps, compiling and then linking your C file).\nWe can fix this error by linking against the math library. This is a shared library, meaning that its code can be used by any program on your computer, and the code is loaded dynamically when the program runs instead of being part of the executable. (All modern operating systems have shared libraries, but they use different file extensions. On Linux they are .so files, macOS uses .dylib, and Windows uses .dll.) Each executable contains a list of shared libraries that should be loaded, and linking against a shared library just adds its name to this list.\nLibrary names are prefixed with lib. The math library is libm. To link against a library, you use -l followed by the name of the library without the prefix, so the math library is -lm. Let’s recompile with this flag:\n$ clang -Wall -Wextra -Werror -Wpedantic hypot.c -o hypot -lm This time, the program handles the entire range of square roots:\n$ ./hypot side a: 2 side b: 2 c = 2.828427 Besides the fact that compilation succeeded, how do we know that the math library was linked properly? There’s a utility called ldd that lists which libraries a given executable links against. Let’s try it on our hypot binary:\n$ ldd hypot linux-vdso.so.1 (0x00007ffdc0912000) libm.so.6 =\u003e /usr/lib/libm.so.6 (0x00007fa15dbbd000) libc.so.6 =\u003e /usr/lib/libc.so.6 (0x00007fa15d9f1000) /lib64/ld-linux-x86-64.so.2 =\u003e /usr/lib64/ld-linux-x86-64.so.2 (0x00007fa15dd43000) The exact output may differ from system to system, but you should at least see libm and libc. libc is the standard C library, and it is linked by default. That’s why we can call functions like printf and scanf without any linker flags—they are part of libc.\nAnother interesting thing about this output is that it shows where each library is stored. On my system, they are all in /usr/lib. I tried this on an Ubuntu system and they were in /lib/x86_64-linux-gnu (suggesting that you could also have dynamic libraries installed for different CPU architectures). Fortunately, the system determines the exact path when your executable is running. This means I could copy my hypot executable onto an Ubuntu system (or copy an executable compiled on Ubuntu onto my system), and it would still find all the libraries it needs.\nSplitting up our program We have successfully modified our program to use the system’s sqrt function instead of our own janky one! All that remains is to, as promised, move the my_hypot function into its own file.\nWe’ll create two new files: a header, mathlib.h, and a C file, mathlib.c. Insert the following contents:\n// mathlib.h #pragma once  double my_hypot(double a, double b); // mathlib.c #include \"mathlib.h\" #include \u003cmath.h\u003e double my_hypot(double a, double b) { return sqrt(a * a + b * b); } The line #pragma once in mathlib.h ensures that the header file is only included once. It won’t make a difference in this tutorial, but in more advanced programs where one header file includes another header file (e.g. to get type definitions), you may get errors about multiple definitions of the contents of a header without #pragma once.\nWe also need to include the header file (not the C file!) from our main hypot.c. Add the #include statement:\n// hypot.c #include \u003cstdio.h\u003e#include \u003cstdlib.h\u003e#include \u003cmath.h\u003e// new line #include \"mathlib.h\" double my_hypot(double a, double b) { return sqrt(a * a + b * b); } int main(void) { double a, b; printf(\"side a: \"); if (!scanf(\"%lf\", \u0026a)) { fprintf(stderr, \"invalid input\\n\"); return 1; } printf(\"side b: \"); if (!scanf(\"%lf\", \u0026b)) { fprintf(stderr, \"invalid input\\n\"); return 1; } printf(\"c = %lf\\n\", my_hypot(a, b)); return 0; } We #include headers, not C files, because the C file is going to be compiled separately and linked. The file with the include statement only needs the declarations of functions, not definitions.\nYou may already be thinking of some other changes we’ll have to make to hypot.c. Let’s add mathlib.c as an input file to our last compilation command, and try compiling this:\n$ clang -Wall -Wextra -Werror -Wpedantic hypot.c mathlib.c -o hypot -lm /usr/bin/ld: /tmp/mathlib-5b7ded.o: in function `my_hypot': mathlib.c:(.text+0x0): multiple definition of `my_hypot'; /tmp/hypot-96432d.o:hypot.c:(.text+0x0): first defined here clang-12: error: linker command failed with exit code 1 (use -v to see invocation) Zeroing in on that error, the main issue is multiple definition of `my_hypot'. It says that one definition is in mathlib.c and another is in hypot.c. Let’s remove the one in hypot.c (we also remove #include \u003cmath.h\u003e since this file no longer needs to call sqrt):\n#include \u003cstdio.h\u003e#include \u003cstdlib.h\u003e #include \"mathlib.h\" // my_hypot function removed  int main(void) { double a, b; printf(\"side a: \"); if (!scanf(\"%lf\", \u0026a)) { fprintf(stderr, \"invalid input\\n\"); return 1; } printf(\"side b: \"); if (!scanf(\"%lf\", \u0026b)) { fprintf(stderr, \"invalid input\\n\"); return 1; } printf(\"c = %lf\\n\", my_hypot(a, b)); return 0; } If we compile this using the same command as before, it works!\nAutomating compilation with Make We’re almost ready to reduce our entire compilation process to just one command, but first we must learn one more concept.\nObject files An executable file (like the hypot file that we are creating) contains several things:\n machine code for every function in your program an entry point (in C, the main function) where execution should begin data that the program will need when it runs (e.g. the \"side a: \") string that we print space for global variables a list of dynamic libraries that should be loaded  An object file is similar to an executable, but different in some important ways. At the fundamental level, object files still contain executable code. An executable file is your whole program, but for programs with multiple source files, an object file is the compiled version of a single C file. Since object files cannot run on their own, they don’t have an entry point (they could have a function called main, however). Also, in an executable file, every function that’s referenced must be defined either in the executable itself, or in a dynamic library that is linked. Object files can reference external functions.\nTo compile a C program, you compile each C file into an object file, and then link those object files into one executable. Even if you don’t list these steps explicitly, Clang still performs both steps; it just deletes the object files when it’s done. The linking process entails:\n combining all the code in the various object files, making sure there are no functions with the same name for each function call, figuring out where that function will actually be located (in the binary or in a dynamic library) at runtime making sure there is a main function, and marking it as the entry point producing the final binary  Manually compiling and linking First, let’s run the commands to compile our C files to object files and link them. This is what make will eventually do for us.\nThe -c flag tells Clang to output an object file instead of an executable. By default, it will just replace .c with .o, but you can also specify the location of the object file manually with -o. Delete the hypot binary if you still have it from a previous section, and then let’s compile hypot.c and see what it creates:\n$ clang -Wall -Wextra -Werror -Wpedantic -c hypot.c $ ls hypot.c hypot.o mathlib.c mathlib.h Even though hypot.c uses functions from mathlib.c, it compiles just fine. But let’s try linking it. The command to link object files is the same as the command to link C files, except you specify object files as input. We also omit the warning flags, since those only affect the compiler, not the linker.\n$ clang hypot.o -o hypot /usr/bin/ld: hypot.o: in function `main': hypot.c:(.text+0xc1): undefined reference to `my_hypot' clang-12: error: linker command failed with exit code 1 (use -v to see invocation) It’s complaining that it can’t find the my_hypot function, since that is in a different file. Note that we got this error during linking and not compilation, since object files are allowed to reference functions from other files. Let’s compile mathlib.c into an object file and try again:\n$ clang -Wall -Wextra -Werror -Wpedantic -c mathlib.c $ ls hypot.c hypot.o mathlib.c mathlib.h mathlib.o $ clang hypot.o mathlib.o -o hypot /usr/bin/ld: mathlib.o: in function `my_hypot': mathlib.c:(.text+0x2b): undefined reference to `sqrt' clang-12: error: linker command failed with exit code 1 (use -v to see invocation) Now it can find my_hypot, but it still can’t find sqrt since we aren’t linking the math library. We can add the -lm flag the same way as before:\n$ clang -lm hypot.o mathlib.o -o hypot $ ls hypot hypot.c hypot.o mathlib.c mathlib.h mathlib.o It worked!\nCurrently, after changing our code, we would have to:\n recompile any C file(s) that we changed into new object files link all our object files (including ones that didn’t change) into a new binary  This will become impractical quickly. Let’s automate it!\nMake Make is a utility to automate your build process. It reads a Makefile (which is just a text file exactly called Makefile) for instructions on how to produce various files, and builds the one that you specified.\nThe true power of Make lies in its dependency system. You can specify the files that a file depends on (for instance, our binary hypot depends on the object files hypot.o and mathlib.o). When you use Make to build one file, it will automatically build all the file’s dependencies. But it will also look at when the various files were modified, and avoid rebuilding dependencies that have not changed since the file that depends on them was rebuilt. In our example, this means that if we run make, change hypot.c, and run make again, it won’t bother recompiling mathlib.c. This saves a lot of time for large programs!\nWe’re going to build up our Makefile a little bit at a time. Create a file called Makefile with the following contents:\nCC = clang CFLAGS = -Wall -Wextra -Werror -Wpedantic LDFLAGS = -lm EXEC = hypot OBJS = hypot.o mathlib.o These are variables that we’ll use later in the Makefile.\n CC is the name of the C compiler that we use CFLAGS are the flags that are passed to the compiler LDFLAGS are the flags that are passed to the linker EXEC is the name of the executable file we are making OBJS is the list of object files that we want to compile and link  Let’s add the next parts to our Makefile:\nCC = clang CFLAGS = -Wall -Wextra -Werror -Wpedantic LDFLAGS = -lm EXEC = hypot OBJS = hypot.o mathlib.o $(EXEC): $(OBJS) $(CC) $(LDFLAGS) -o $(EXEC) $(OBJS) Make sure the last line is indented with tabs, not spaces. Make requires tabs.\nThis looks complicated! The main thing going on is that $(VAR) gets replaced with the variable VAR. If we perform those replacements manually, those last two lines look like:\nhypot: hypot.o mathlib.o clang -lm -o hypot hypot.o mathlib.o This is one target. A target begins with the line target: dependencies, so in this case we are saying that hypot is a target which depends on hypot.o and mathlib.o. After this line come the command(s) to build that file, indented with tabs. You can see that, after all the variables have been substituted, the command here is the same as we were already using to link the executable.\nLet’s keep going! Next we’ll add targets to build our object files:\nCC = clang CFLAGS = -Wall -Wextra -Werror -Wpedantic LDFLAGS = -lm EXEC = hypot OBJS = hypot.o mathlib.o $(EXEC): $(OBJS) $(CC) $(LDFLAGS) -o $(EXEC) $(OBJS) hypot.o: hypot.c $(CC) $(CFLAGS) -c hypot.c mathlib.o: mathlib.c $(CC) $(CFLAGS) -c mathlib.c We list the C files as dependencies of these targets to ensure that each object file gets rebuilt when its corresponding C file changes. But unlike the previous example, the C files will not get their own targets in the Makefile, since those files are created by us and not Make. Since Make knows it isn’t responsible for creating the C files, it will just check that each one exists before it tries to build the object file, and throw an error if one is missing.\nWe’re going to add some more to the Makefile, but this is already enough to build our program! Let’s try it out. To build a Make target, just run make \u003ctarget name\u003e in the directory containing the Makefile. If you don’t specify a target, it will use the first one that is defined. In our Makefile, that is the $(EXEC) rule, so we are good to go. Make sure to delete your object files and executable, if you still have them from previous sections.\n$ ls hypot hypot.c hypot.o Makefile mathlib.c mathlib.h mathlib.o $ rm hypot *.o $ ls hypot.c Makefile mathlib.c mathlib.h $ make clang -Wall -Wextra -Werror -Wpedantic -c hypot.c clang -Wall -Wextra -Werror -Wpedantic -c mathlib.c clang -lm -o hypot hypot.o mathlib.o $ ls hypot hypot.c hypot.o Makefile mathlib.c mathlib.h mathlib.o $ ./hypot side a: 2 side b: 3 c = 3.605551 It worked! Note how Make prints out the commands that it runs. Let’s try compiling it again:\n$ make make: 'hypot' is up to date. It didn’t recompile because it has already built everything that it needs, and we didn’t change our C files.\nA more advanced Makefile This Makefile works fine, but it can do more. We’re going to make a few changes.\nSeparate all target In a more advanced project, you might have multiple executable files that should be compiled. Right now, we couldn’t run make to compile multiple executables, because it only runs the first target by default.\nWe can use something called a phony target to remedy this. A phony target is a target that doesn’t correspond to a single file. In this case, we create a target called all with all our executables (there is still only one, but there could be more) as dependencies, and put it first in the Makefile:\nCC = clang CFLAGS = -Wall -Wextra -Werror -Wpedantic LDFLAGS = -lm EXEC = hypot OBJS = hypot.o mathlib.o all: $(EXEC) $(EXEC): $(OBJS) $(CC) $(LDFLAGS) -o $(EXEC) $(OBJS) hypot.o: hypot.c $(CC) $(CFLAGS) -c hypot.c mathlib.o: mathlib.c $(CC) $(CFLAGS) -c mathlib.c We’ve listed hypot as the sole dependency of the all target. If there were a file called all in our project, we would need to name this target something else, because Make would think that it had already been built. Note that there are no commands to build all, because it will still run the commands to build hypot. Feel free to try deleting the executable and/or object files and running make again.\nCleanup It’s common to include a target called clean that deletes all executables and object files. We’ll do this using rm with the -f flag (“force”). The flag means that if we ask it to delete a file that doesn’t exist, it will silently ignore that argument instead of producing an error, so we can still run our clean target even if there isn’t anything for it to delete.\nCC = clang CFLAGS = -Wall -Wextra -Werror -Wpedantic LDFLAGS = -lm EXEC = hypot OBJS = hypot.o mathlib.o all: $(EXEC) $(EXEC): $(OBJS) $(CC) $(LDFLAGS) -o $(EXEC) $(OBJS) hypot.o: hypot.c $(CC) $(CFLAGS) -c hypot.c mathlib.o: mathlib.c $(CC) $(CFLAGS) -c mathlib.c clean: rm -f $(EXEC) $(OBJS) clean has no dependencies, and the command uses our variables to delete the files that it should. Let’s try it, first using make to make sure our program is compiled.\n$ make make: Nothing to be done for 'all'. $ ls hypot hypot.c hypot.o Makefile mathlib.c mathlib.h mathlib.o $ make clean rm -f hypot hypot.o mathlib.o $ ls hypot.c Makefile mathlib.c mathlib.h Automatically compiling object files Right now, if we added another C file to our program, we’d have to add a new target to our Makefile and copy the command to compile it. This can get unwieldy, and we run the risk of introducing a subtle bug by copying the command incorrectly.\nFortunately, Make allows us to specify much more general rules. Specifically, we can tell it how to compile any object file from the corresponding C file:\nCC = clang CFLAGS = -Wall -Wextra -Werror -Wpedantic LDFLAGS = -lm EXEC = hypot OBJS = hypot.o mathlib.o all: $(EXEC) $(EXEC): $(OBJS) $(CC) $(LDFLAGS) -o $(EXEC) $(OBJS) %.o: %.c $(CC) $(CFLAGS) -c $\u003c clean: rm -f $(EXEC) $(OBJS) The syntax here is tricky. The % symbols create a correspondence between the names of the object file and C file: any filename ending with .o depends on the same filename but with .c instead of .o. In the compilation command, $\u003c gets replaced with the name of the dependency, i.e. the name of the C file.\nLet’s check that this works, using make clean first to make sure it has to recompile everything:\n$ make clean rm -f hypot hypot.o mathlib.o $ ls hypot.c Makefile mathlib.c mathlib.h $ make clang -Wall -Wextra -Werror -Wpedantic -c hypot.c clang -Wall -Wextra -Werror -Wpedantic -c mathlib.c clang -lm -o hypot hypot.o mathlib.o $ ls hypot hypot.c hypot.o Makefile mathlib.c mathlib.h mathlib.o And it does!\nFormatting with clang-format If you use clang-format and have a configuration file (.clang-format) next to your code, you can add a target to run it with make format (here, the rest of the Makefile is omitted, since the target is not specific to our code):\nformat: clang-format -i -style=file *.[ch] Static analysis with scan-build scan-build is a program that detects additional problems with your code at compile time (that a compiler normally would not). We can also call it with a Makefile target:\nscan-build: clean scan-build --use-cc=$(CC) make This target isn’t as straightforward as the clang-format one. Some details to note are:\n scan-build’s argument is the command that builds our program. Here, that is just make. We list clean as a dependency. This ensures that all object files and executables are deleted before we run scan-build, so when scan-build runs make, the whole program is rebuilt. scan-build sometimes overrides the compiler used by Make. We specify --use-cc=$(CC) (effectively --use-cc=clang) to make sure that it will run using the same compiler that we normally use (as opposed to, say, GCC).  Here’s an example of running it:\n$ make scan-build rm -f hypot hypot.o mathlib.o scan-build --use-cc=clang make scan-build: Using '/usr/bin/clang-12' for static analysis make[1]: warning: jobserver unavailable: using -j1. Add '+' to parent make rule. make[1]: Entering directory '/home/ben/code/c/ucsc-guide-hypot' /usr/bin/../lib/clang/ccc-analyzer -Wall -Wextra -Werror -Wpedantic -c hypot.c /usr/bin/../lib/clang/ccc-analyzer -Wall -Wextra -Werror -Wpedantic -c mathlib.c /usr/bin/../lib/clang/ccc-analyzer -lm -o hypot hypot.o mathlib.o make[1]: Leaving directory '/home/ben/code/c/ucsc-guide-hypot' scan-build: Analysis run complete. scan-build: Removing directory '/tmp/scan-build-2021-10-11-005941-146456-1' because it contains no reports. scan-build: No bugs found. Expanding our program You’ve now seen everything you need to know to use Makefiles. In this last section, I will demonstrate how the build process would change if you wanted to add more C files to your project. We’re going to add one more C file and also have our Makefile compile a second binary in addition to hypot.\nIn the spirit of CSE 13S assignment 2, we’ll build a test harness that compares the results of our my_hypot function with the standard library’s hypot. The results should be identical, since we’re also using the standard library’s sqrt function and the calculation for what to take the square root of is trivial, but doing this will let us expand on our program.\nHere’s the code for the test harness. Save it in hypot-test.c:\n// hypot-test.c #include \u003cmath.h\u003e#include \u003cstdio.h\u003e #include \"mathlib.h\" int main(void) { for (double a = 1.0; a \u003c= 4.0; a += 1.0) { for (double b = 1.0; b \u003c= 4.0; b += 1.0) { double hypot_result = hypot(a, b), my_hypot_result = my_hypot(a, b), difference = fabs(hypot_result - my_hypot_result); printf(\"a = %.0f, b = %.0f: hypot = %16.15lf, my_hypot = %16.15lf, diff \" \"= %16.15lf\\n\", a, b, hypot_result, my_hypot_result, difference); } } return 0; } We can compile it manually, making sure to link against the math library and our own mathlib.o (run make again if you don’t have the object file):\n$ clang -Wall -Werror -Wextra -Wpedantic -c hypot-test.c $ clang -lm -o hypot-test hypot-test.o mathlib.o $ ./hypot-test a = 1, b = 1: hypot = 1.414213562373095, my_hypot = 1.414213562373095, diff = 0.000000000000000 a = 1, b = 2: hypot = 2.236067977499790, my_hypot = 2.236067977499790, diff = 0.000000000000000 a = 1, b = 3: hypot = 3.162277660168380, my_hypot = 3.162277660168380, diff = 0.000000000000000 a = 1, b = 4: hypot = 4.123105625617661, my_hypot = 4.123105625617661, diff = 0.000000000000000 a = 2, b = 1: hypot = 2.236067977499790, my_hypot = 2.236067977499790, diff = 0.000000000000000 a = 2, b = 2: hypot = 2.828427124746190, my_hypot = 2.828427124746190, diff = 0.000000000000000 a = 2, b = 3: hypot = 3.605551275463989, my_hypot = 3.605551275463989, diff = 0.000000000000000 a = 2, b = 4: hypot = 4.472135954999580, my_hypot = 4.472135954999580, diff = 0.000000000000000 a = 3, b = 1: hypot = 3.162277660168380, my_hypot = 3.162277660168380, diff = 0.000000000000000 a = 3, b = 2: hypot = 3.605551275463989, my_hypot = 3.605551275463989, diff = 0.000000000000000 a = 3, b = 3: hypot = 4.242640687119285, my_hypot = 4.242640687119285, diff = 0.000000000000000 a = 3, b = 4: hypot = 5.000000000000000, my_hypot = 5.000000000000000, diff = 0.000000000000000 a = 4, b = 1: hypot = 4.123105625617661, my_hypot = 4.123105625617661, diff = 0.000000000000000 a = 4, b = 2: hypot = 4.472135954999580, my_hypot = 4.472135954999580, diff = 0.000000000000000 a = 4, b = 3: hypot = 5.000000000000000, my_hypot = 5.000000000000000, diff = 0.000000000000000 a = 4, b = 4: hypot = 5.656854249492381, my_hypot = 5.656854249492381, diff = 0.000000000000000 Next, let’s modify our Makefile to automatically build hypot-test. First, we’ll rename the existing OBJS to HYPOT_OBJS, since we’ll eventually create a new list of object files that are needed for hypot-test. We’ll also remove the EXEC variable and instead write hypot directly:\nCC = clang CFLAGS = -Wall -Wextra -Werror -Wpedantic LDFLAGS = -lm HYPOT_OBJS = hypot.o mathlib.o all: hypot hypot: $(HYPOT_OBJS) $(CC) $(LDFLAGS) -o hypot $(HYPOT_OBJS) %.o: %.c $(CC) $(CFLAGS) -c $\u003c clean: rm -f hypot $(HYPOT_OBJS) format: clang-format -i -style=file *.[ch] scan-build: clean scan-build --use-cc=$(CC) make Now we can add HYPOT_TEST_OBJS with the object files that this program needs, as well as a hypot-test target. We’ll also add hypot-test as a dependency of the all target, so that running make with no arguments builds both hypot and hypot-test. And finally, we’ll add the executable and object files to our clean target:\nCC = clang CFLAGS = -Wall -Wextra -Werror -Wpedantic LDFLAGS = -lm HYPOT_OBJS = hypot.o mathlib.o HYPOT_TEST_OBJS = hypot-test.o mathlib.o all: hypot hypot-test hypot: $(HYPOT_OBJS) $(CC) $(LDFLAGS) -o hypot $(HYPOT_OBJS) hypot-test: $(HYPOT_TEST_OBJS) $(CC) $(LDFLAGS) -o hypot-test $(HYPOT_TEST_OBJS) %.o: %.c $(CC) $(CFLAGS) -c $\u003c clean: rm -f hypot hypot-test $(HYPOT_OBJS) $(HYPOT_TEST_OBJS) format: clang-format -i -style=file *.[ch] scan-build: clean scan-build --use-cc=$(CC) make Let’s test this out by running make clean and then having it recompile everything with make:\n$ ls hypot hypot.o hypot-test.c Makefile mathlib.h hypot.c hypot-test hypot-test.o mathlib.c mathlib.o $ make clean rm -f hypot hypot-test hypot.o mathlib.o hypot-test.o mathlib.o $ ls hypot.c hypot-test.c Makefile mathlib.c mathlib.h $ make clang -Wall -Wextra -Werror -Wpedantic -c hypot.c clang -Wall -Wextra -Werror -Wpedantic -c mathlib.c clang -Wall -Wextra -Werror -Wpedantic -c hypot-test.c clang -lm -o hypot hypot.o mathlib.o clang -lm -o hypot-test hypot-test.o mathlib.o $ ls hypot hypot.o hypot-test.c Makefile mathlib.h hypot.c hypot-test hypot-test.o mathlib.c mathlib.o $ ./hypot side a: 3 side b: 4 c = 5.000000 $ ./hypot-test a = 1, b = 1: hypot = 1.414213562373095, my_hypot = 1.414213562373095, diff = 0.000000000000000 a = 1, b = 2: hypot = 2.236067977499790, my_hypot = 2.236067977499790, diff = 0.000000000000000 a = 1, b = 3: hypot = 3.162277660168380, my_hypot = 3.162277660168380, diff = 0.000000000000000 a = 1, b = 4: hypot = 4.123105625617661, my_hypot = 4.123105625617661, diff = 0.000000000000000 a = 2, b = 1: hypot = 2.236067977499790, my_hypot = 2.236067977499790, diff = 0.000000000000000 a = 2, b = 2: hypot = 2.828427124746190, my_hypot = 2.828427124746190, diff = 0.000000000000000 a = 2, b = 3: hypot = 3.605551275463989, my_hypot = 3.605551275463989, diff = 0.000000000000000 a = 2, b = 4: hypot = 4.472135954999580, my_hypot = 4.472135954999580, diff = 0.000000000000000 a = 3, b = 1: hypot = 3.162277660168380, my_hypot = 3.162277660168380, diff = 0.000000000000000 a = 3, b = 2: hypot = 3.605551275463989, my_hypot = 3.605551275463989, diff = 0.000000000000000 a = 3, b = 3: hypot = 4.242640687119285, my_hypot = 4.242640687119285, diff = 0.000000000000000 a = 3, b = 4: hypot = 5.000000000000000, my_hypot = 5.000000000000000, diff = 0.000000000000000 a = 4, b = 1: hypot = 4.123105625617661, my_hypot = 4.123105625617661, diff = 0.000000000000000 a = 4, b = 2: hypot = 4.472135954999580, my_hypot = 4.472135954999580, diff = 0.000000000000000 a = 4, b = 3: hypot = 5.000000000000000, my_hypot = 5.000000000000000, diff = 0.000000000000000 a = 4, b = 4: hypot = 5.656854249492381, my_hypot = 5.656854249492381, diff = 0.000000000000000 It all worked! Make handles building multiple binaries very well—notice how it only built mathlib.c once, even though it is needed by both binaries. Also, this Makefile compiles both binaries by default (thanks to the all target), but you can also compile only one binary with make hypot or make hypot-test.\n","categories":"","description":"Compilation, linking, header files, object files, and Makefiles\n","excerpt":"Compilation, linking, header files, object files, and Makefiles\n","ref":"/ucsc-guide/docs/majorguides/computerscience/cprogramming/compilation/","tags":"","title":"Compilation"},{"body":"Introduction to Python Table of Contents  Introduction to Python  Table of Contents   1. Getting into Programming  1.1 What is programming? 1.2 Python 1.3 Using the internet 1.4 Getting started   2. Your first program 3. Variables, data types, and operators 4. Loops  4.1 If loops 4.2 While loops 4.3 For loops 4.4 List iteration 4.4 Nested loops   5. Control flow  5.1 Break statement 5.2 Continue statement 5.3 Pass   6. Functions  6.1 Docstrings 6.2 Return 6.3 Default return and None   7. Data structures  7.1 The stack 7.2 The queue   8. Strings  8.1 String operators 8.2 Slicing 8.3 String comparison  Option 1: Using relational operators Option 2: using is and is not   8.4 Formatting   9. Lists cont.  9.1 Indices 9.2 List slicing 9.3 List sorting 9.4 List comprehension   10. Generators 11. Dictionaries cont. 12. Classes and objects  12.1 Classes 12.2 Objects 12.3 More complex classes 12.4 Inheritance 12.5 Inheritance vs composition   13. Recursion 14. Conclusion  1. Getting into Programming 1.1 What is programming? Programming is the process or activity of writing computer programs. Another way to think of programming is creating “things” that the computer can understand and execute. What you will be doing in your upcoming courses is writing computer programs in the language known as python.\n1.2 Python Python is an interpreted high-level general-purpose programming language. Interpreted means that the language does not to be compiled before running (unlike C++ or C for example). High-level means that it’s easier for the human to read and understand compared to the 1’s and 0’s computers see. Python’s design philosophy emphasizes code readability with its use of significant indentation. Its language constructs as well as its object-oriented approach aim to help programmers write clear, logical code for small and large-scale projects. In other words, it’s a great language for new programmers!\n1.3 Using the internet When first starting programming, you might come across a lot of different terms that you’re unfamiliar with. An important lesson to learn early on is that Google is your friend. If there’s anything you’re confused about, just look it up and there will be an explanation out there. Just be careful with looking up solutions for your labs because that’s against course policy and can result in academic dishonety violations.\n1.4 Getting started Your course instructor will probably have a section on getting started but here’s what you should do in case you want to get a head start:\n install the latest version of python download the IDE (integrated development environment) or text editor of your choice create a .py file with your name of choice open said file from step 3 in your text editor or IDE and start coding!  2. Your first program It’s common practice for the first program you make to be a simple one. Print is used to print things to the console in python. Try to print your name and age to the console as your first program!\nCode:\nprint(\"my name is James Zhou and I'm 19 years old\") Output:\nmy name is James Zhou and I’m 19 years old\n3. Variables, data types, and operators One thing you might have noticed when making your first program is that in order to print out your name and age, the arguments inside the print needed to be wrapped in quotation marks. This is because your name is most likely a string, which is a data type. Python has several built-in data types but the ones you will use the most are:\n int (integers)\nThese numbers respresent integers, like on a number line.  x = 1 y = 3 float\nFloats are decimal representations of numbers.  float_pi = 3.1415 balance = 103.23 char (character)\nChars are characters, like ‘a’, ‘b’, and ‘c’. Unlike other programming languages, chars are just strings with single letters stored inside but it’s a good term to use for future classes.  firstInitial = 'J' lastInitial = 'Z' str (strings)\nStrings are arrays of chars that form comprehensible (or incomprehensible) words and sentences.  firstName = \"James\" lastName = \"Zhou\" list\nLists are arrays of different objects. The cool thing about python is that arrays can hold different objects unlike other languages which makes complex programs a lot easier.  friends = [\"Isaac\", \"Brian\", \"Brent\", \"Vincent\", \"Aaron\"] fruit = [\"Apples\", 5, \"Pears\", 10] tuple\nTuples in their most basic form are just immutable lists (lists that can’t be changed) with parantheses instead of brackets.  coord1 = (0,0) coord2 = (3,0) coord3 = (0,4) set\nSets might seem like lists, but they are very different. First, they use curley braces instead. Additionally, they are unordered, unindexed, don’t allow duplicates, and immutable.  test_set = {\"a\", \"b\", \"c\"} dict (dictionary)\nDictionaries are used to store data values in key:value pairs and are useful for finding data quickly instead of searching through an entire list. A dictionary is ordered, changeable, and does not allow duplicates.  car1 = { \"brand\": \"Ferrari\", \"model\": \"SF90 Stradale\", \"year\": 2020 } bool (boolean)\nNamed after George Boole, booleans hold True or False values.  answer1 = True answer2 = False 4. Loops There are many different loops in python. Here a a few that you’ll become familiar with.\n4.1 If loops If loops are yes or no loops. If the statement given to the if loop is true, it will execute the if loop. Otherwise, the loop woop won’t execute. Else is the opposite of if. If the if loop doesn’t execute, then the else loop will execute. If loops can be chained with an if else statement. Here are some examples to help visualize if loops.\nif (true): print(\"this loop is executed\") if (false): print(\"this loop is not executed\") print(\"this still gets printed\") if (false): print(\"this loop is not executed\") else: print(\"this loop is executed\") if (false): print(\"this loop is not executed\") else if (true): print(\"this loop is executed\") else: print(\"this loop is not executed\") Here are some examples to test your understanding:\n#what is the output? x = 5 if (x + 5 === 10): print(x) print(x+5) #what is the output? grade = 95 if (grade \u003c 60): print(\"you got an F\") if (grade \u003e 70): print(\"you got a C\") if (grade \u003e 80): print(\"you got a B\") else if (grade \u003e 90): print(\"you got an A\") else: print(\"please enter a valid grade\") 4.2 While loops The while loop will execute a set of statements as long as a condition is true. This can potentially lead to infinite loops so be careful when writing the check statement.\ni = 0 while(i\u003c10): print(i) i++ #what is the output? i = 10 counter = 0 while (i \u003e 5): counter+=i print(counter) #what is the output? i = 1 while (i == 0): i++ print(i) 4.3 For loops The for loop iterates a set of statements for however many iterations are set when defining the for loop. This can also lead to infinite loops if not careful in setting up definitions.\nfor x in range(10): print(x) for x in range(0,10,2): print(x) output:\n0 2 4 6 8 4.4 List iteration For loops can also be used to iterate through the contents of a list.\nnames = [\"bob\", \"joe\", \"harry\", \"jenny\", \"rose\", \"miguel\"] for x in names: print(x) output:\nbob joe harry jenny rose miguel #what is the output? arr = [1, 2, 3, \"a\", \"c\", \"hello\", 2.34, False, {1,2,3}, [0,-5,3]] for x in arr: print(x) output:\n1 2 3 a c hello 2.34 False {1, 2, 3} [0, -5, 3] 4.4 Nested loops In python, loops can be put inside of each other. This results in what’s called a “nested loop”.\nGenerally, python flows down the chain of loops so the inner loops always finish running before the outer loop can continue.\nfor i in range(3): for j in range(3): print(\"(\"+str(i)+\",\"+str(j)+\")\") output:\n(0,0) (0,1) (0,2) (1,0) (1,1) (1,2) (2,0) (2,1) (2,2) These loops can take a very long time to execute if the parameters or chaining is long. There are often smarter ways to display or check values so only use this if you have to.\n5. Control flow A program’s control flow is the order in which the program’s code executes. Generally, the flow of executing statements is linear. For example:\nprint(1) print(2) print(3) Will print:\n1 2 3 As you can see, the execution of the print statements happens linearlly.\nThe control flow of a Python program is regulated by conditional statements, loops, and function calls. Using these can be useful if you want the computer to jump between lines of code, functions, and applications.\n5.1 Break statement The break statement in python terminates the current loop and being run and resumes execution at the next statement.\nThe most common use for a break statement is when some external condition occurs requiring a quick exit from a loop that would normally run until its condition is fulfilled.\nWhen using nested loops, the break statement stops the execution of the innermost loop and starts executing the next line of code after the block. Here are some examples to help visualize a break statement:\nfor i in range(100): if i == 3: break print('Current number :', i) Output:\nCurrent number : 3 As you can see, the innermost loop is exited but the next line of code after the block is then executed, thus cancelling the “outer” for loop. There are many more cases in which breaks can be used but I’ll let your CS classes teach you those.\n5.2 Continue statement The continue statement sets the control flow back to the beginning of a loop. The continue statement does not execute all the remaining statements in the current iteration of the loop. Think of it as going directly to Go in Monopoly.\nfor i in range(3): if i == 2: continue print(\"num \", i) Output:\nnum 0 num 1 The example above shows how when i == 2, the continue statement gets triggered, skipping the print statement.\n5.3 Pass Pass is a simple place holder statement or null statement that does not do anything. It’s similar to white space but the computer does recognize it. The syntax is just “pass”.\n6. Functions Functions are a block of code which only runs when the function itself is called. Data, known as parameters, can be passed into a function which can then be operated on. A function can return data as a result which can then in turn feed into other functions.\nFunctions can range from simple modularization of code to complex algorithms. I’ll keep it simple for now though and just show the syntax.\nIn your future courses, you will become well acquainted with the versatility and variety of functions.\n''' definition of a function the def is important as it distinguises it to the computer that a function is ahead parameters go inside the parantheses, which can then be used inside the function ''' def printName(firstName, lastName): print(\"Hello,\", firstName, lastName) ''' calling functions is simple ''' printName(\"James\",\"Zhou\") Output:\nHello, James Zhou Here is an example using return, which will be covered in more detail later.\ndef getSum(x,y): return x+y print(getSum(10,10)) Output:\n20 6.1 Docstrings Python docstrings are string literals that appear right after the definition of a function, method, class, or module. These are used to inform the coder(s) what the function/purpose of your code is. They are slighlty different from comments in that using the  __doc__ attribute, you can access the string literal.\nHere’s an example:\ndef getSum(x,y): '''this function returns the sum of 2 numbers''' return x+y print(getSum.__doc__) Output:\nthis function returns the sum of 2 numbers 6.2 Return The return keyword is to exit a function and return a value. This can be useful for control flow as well as retrieving data for later use.\ndef longProgram(): for i in range(1000000): if i == 10: return i print(longProgram()) Output:\n10 Another example:\ndef pythag(a,b): answer = getSum(exponent(a,2), exponent(b,2)) answer = exponent(answer, 1/2) return answer def getSum(a,b): return a+b def exponent(a,b): return a**b print(pythag(3,4)) Output:\n5.0 6.3 Default return and None The default return is always None in python. If a return statement is left empty, than None is returned as default. This can be useful if you want to exit a function entirely at a certain point.\ndef test(): return print(test()) Output:\nNone None is pretty self-explanitory; it holds no value.\n7. Data structures The two data structures you will encounter in your early CS classes are the stack and the queue.\n7.1 The stack The stack is a linear data structure that stores items in a Last-In/First-Out (LIFO) or First-In/Last-Out (FILO) style. In a stack, a new element is added at one end and an element is removed from that end only. The insert and delete operations are often called push and pop.\nThe analogy professors usually use is a stack of plates. It’s impossible to remove the bottom plate once the stack starts growing so the only way to get to the bottom is to remove all the new plates before getting to the last plate, hence the name FILO.\nStacks are usually built with lists due to their mutability.\nThere are several functions built-into python that are associated with stacks:\nempty() #Returns whether the stack is empty size() #Returns the size of the stack top() #Returns a reference to the topmost element of the stack push(a) #Inserts the element ‘a’ at the top of the stack pop() #Deletes the topmost element of the stack 7.2 The queue Like a stack, the queue is a linear data structure that stores items in but in a First In First Out (FIFO) manner.\nWith a queue the newest added item is removed first.\nA good analogy of a queue is like a queue of diners waiting to enter the dining hall. Whoever gets there first, gets to go in first.\nThere are several functions that are associated with queues (not built-in):\nEnqueue: # Adds an item to the queue. If the queue is full, then it is said to be an Overflow condition Dequeue: # Removes an item from the queue. The items are popped in the same order in which they are pushed. If the queue is empty, then it is said to be an Underflow condition Front: # Get the front item from queue Rear: # Get the last item from queue 8. Strings Strings might seem pretty simple but there are a lot of tricks and caveats to them which will be summarized in this chapter.\n8.1 String operators Python has several built-in string operators that make operating on strings much easier. Since everything in python is an object, to access the string operators, just attach the function to the end of a string of your choice.\nHere is a good resource for the different string methods:\nhttps://www.w3schools.com/python/python_ref_string.asp\nYou probably won’t use them all but it’s good to know some common ones like capitalize() , casefold()  , count() , split() etc.\nHere’s an example of capitalizing the first letter of each word and returning the string for later use:\nsentence = \"the quick brown fox jumped over the river\" wordList = [] for word in sentence.split(): wordList.append(word.capitalize()) print(wordList) Output:\n['The', 'Quick', 'Brown', 'Fox', 'Jumped', 'Over', 'The', 'River'] 8.2 Slicing Slicing is one of the most frequently used operations on lists and tuples (strings are basically char arrays). As the name implies, slicing takes a “slice” and returns it for later use.\nHere is an example of slicing in action:\nsentence = \"Python is fun\" sentenceSlice = slice(3, 5) print(sentence[sentenceSlice]) Output:\nho sentenceSlice is declared as a slice object from index 3 to index 5 excluding index 5. The string \"Python is fun\" has Pyt for indicies 0-2. ho is then printed because those are the only 2 chars in the selected slice.\nTo really make it clear, here is the syntax:\nrandomSliceObject = slice(start, end, step) Step means how many chars to skip before including the next char in the slice. The default step is 1. Slicing can be done without the declaration of a slice object but we’ll talk about that more when we cover lists in more detail.\n8.3 String comparison Strings like other objects, can be compared in python. There are a few options to choose from. I’ll go over the 2 easiest methods here.\nOption 1: Using relational operators string1 = \"hello\" string2 = \"Hello\" print(string1 \u003c string2) print(string1 \u003c= string2) print(string1 \u003e string2) print(string1 \u003e= string2) print(string1 == string2) print(string1 != string2) Output:\nFalse False True True False True This words by comparing the Ascii values of each character and seeing if they are greater or less than each other. h has a value of 104 while H has a value of 72. With the rest of the letters being the same, we can see why we get the results above.\nOption 2: using is and is not This method uses hex values to check if the string IDs are the same for each string object. It’s a pretty interesting topic that your CS classes will probably go over. It’s similar to the == operation but it doesn’t take into account mutability. If a string is changed and it’s compared with is to another string with the same contents, the returned value will still be false.\nExample:\nstring1 = \"hello\" string2 = \"hellos\" string1 += \"s\" print(string1) print(string2) print(string1 == string2) print(string1 is string2) Output:\nhellos hellos True False 8.4 Formatting Formatting strings isn’t super complicated. To be honest, I haven’t memorized all of the different methods just because you can always pull them up whenever you need. Here’s a good resource if you need a specific formatting tool:\nhttps://www.w3schools.com/python/ref_string_format.asp\nThe syntax is the same for each method. Here’s an example of negative, 2 digit floating point, thousand split syntax:\nbalance = 1234567.890000001 txt = \"{0}{1}'s balance: ${2:+.2f}\".format(\"James\", \"Zhou\", balance) print(txt) Output:\nJames Zhou's balance: $+1234567.89 9. Lists cont. We briefly glossed over the syntax and functionalities of lists earlier but let’s delve a little deeper. Lists are one of the most important data structures that can be scaled to huge scales so having a good understanding of their intricacies is imperative.\n9.1 Indices List indices help address where each item of the list is located. Indices can also be the source of frustration and head ache when working with lists due to the numerous bugs you can encounter. One of the most common bugs for new programmers is the index out of bounds error. This occurs when your program tries to access something outside of the bounds of an array.\nHere’s an example:\nlist1 = [1,2,3] print(list1[3]) Output:\nIndexError: list index out of range To avoid this, make sure your loops' parameters are properly defined to avoid making excessive iterations.\n9.2 List slicing Lists, like strings, can also be sliced. The syntax can be much shorter without even needing to declare a slice object. Here’s an example:\nrandomList = [1,2,3,4,5,6,7,8,9,10] randomList = randomList[0:9:2] print(randomList) Output:\n[1, 3, 5, 7, 9] The syntax is as follows:\nrandomList[ start : end : step ] Slicing can also be done backwards using negative numbers. Try to guess what this output will be:\nrandomList = [1,2,3,4,5,6,7,8,9,10] randomList = randomList[9:0:-2] print(randomList) Output:\n[10, 8, 6, 4, 2] 9.3 List sorting Lists can be sorted in python using the built in sort() method. The built-in method uses TimSort, which is a merge of insertion and merge sort. You’ll learn all about that stuff later but just know that it’s pretty efficient and will serve your purposes.\nHere’s the syntax for ascending order:\nlist1.sort() Here’s the syntax for descending order:\nlist1.sort(reverse=True) A key can also be inserted as a parameter to specify how you want the list to be sorted. Here’s an example of sorting a list based on the value of the 2nd element instead of value:\nlist1 = [(0,0),(1,0),(2,0),(1,10)] list1.sort() print(list1) def getSecond(tupleX): return tupleX[1] list1.sort(key=getSecond) print(list1) Output:\n[(0, 0), (1, 0), (1, 10), (2, 0)] [(0, 0), (1, 0), (2, 0), (1, 10)] 9.4 List comprehension List comprehension is a shorter way to create new lists based on the values of an existing list. This is useful to save time and when working with multiple, larger lists, requiring multiple loops.\nHere’s an example for creating a new list while preserving the old one without list comprehension:\nnames = [\"James\", \"Bob\", \"Charlie\", \"Dom\", \"Ethan\"] newlist = [] for x in names: if len(x) \u003c 6: newlist.append(x) print(newlist) Output:\n['James', 'Bob', 'Dom', 'Ethan'] With list comprehension:\nnames = [\"James\", \"Bob\", \"Charlie\", \"Dom\", \"Ethan\"] newlist = [x for x in names if(len(x) \u003c 6)] print(newlist) Output:\n['James', 'Bob', 'Dom', 'Ethan'] Here’s the syntax:\nnewlist = [expression for item in iterable if(condition)] 10. Generators Generators generate values for use. They don’t require a lot of code to get running. The defining characteristic of a generator is the use of the keyword yield. yield statements behave similarly to return in that they return a value. The similarities stop there though. Unlike how return exits the function as soon as it finishes executing, yield allows the function block to continue firing. You’ll learn a lot more about them in your upcoming CS classes but here is a simple example of a generator:\ndef fib(iterations): a, b = 0, 1 while a \u003c iterations: yield a a, b = b, a + b x = fib(5) print(x.__next__()) print(x.__next__()) print(x.__next__()) print(x.__next__()) print(x.__next__()) Output:\n0 1 1 2 3 Here’s a challenge for you. Try to create a generator for prime numbers and print out the first 100 iterations.\n11. Dictionaries cont. Dictionaries in python can be a useful tool for sorting data. Dictionaries can’t store duplicates and every key needs to be unique, making them a great resource for mapping unique objects.\nThere are several different types of implementations of dictionaries such as hast tables and red-black trees but I’ll let your CS classes explain those concepts.\nDictionaries can store different object and data types inside of them. Dictionaries can also be nested inside of each other. For example:\nperson1 = { \"fName\": \"John\", \"lName\": \"Doe\", \"age\": 27, \"hobbies\": [\"coding\", \"watching TV\", \"eating\"], \"car\" : { \"brand\": \"Ford\", \"model\": \"Mustang\", \"year\": 1990 } } print(person1) print(person1[\"car\"]) print(person1[\"car\"][\"brand\"]) Output:\n{'fName': 'John', 'lName': 'Doe', 'age': 27, 'hobbies': ['coding', 'watching TV', 'eating'], 'car': {'brand': 'Ford', 'model': 'Mustang', 'year': 1990}} {'brand': 'Ford', 'model': 'Mustang', 'year': 1990} Ford There are a lot of ways to use dictionaries. Be creative with their implementation and you’ll be surprised at how useful they can be.\n12. Classes and objects Python is an object oriented programming language, meaning that everything inside of python is an object (besides control flow). This chapter will cover what objects are and the classes that define different objects.\n12.1 Classes Classes in python serve as object blueprints. They detail what an object consists of — its characteristics if you will. Similarly to how we classify certain animals under specific classes (domains), we can do the same with objects. Let’s look at the basic syntax of creating our own python class:\nclass human: name = \"Joe\" age = 0 gender = \"Male\" This is our very own human class. Let’s next look over how to make an object of class human.\n12.2 Objects Using the syntax from above, we can create an object of class human like so:\nclass human: name = \"Joe\" age = 0 gender = \"Male\" human1 = human() print(human1.name) print(human1.age) print(human1.gender) Output:\nJoe 0 Male Unfortunately, every human object we ever create will always have the name of Joe, an age of 0, and be male. Not a particularly useful class as humans come in all varieties. As you can see though, we can access the data of an object using the same approach we used with lists and strings. This is because lists and strings are also objects, just of different classes.\n12.3 More complex classes To make dynamic objects, we need to have flexibility with our class constructors. Here’s how to add parameters, or constructors, to a python class using the function __init()__:\nclass human(): def __init__(self, fName, lName, age, gender): self.fName = fName self.lName = lName self.age = age self.gender = gender Now, when we create a new human object, we can add some uniqueness to it. Using the __init__() function allows us to initialize an object using set parameters that the user can input. We always include self as the first parameter because we need to address the object itself when first initializing the arguments we pass to the constructor. We can add more functions using def but I’ll let you expiriment with that yourself.\nhuman2 = human(\"James\", \"Zhou\", 19, \"Male\") print(human2.fName) print(human2.lName) print(human2.age) print(human2.gender) Output:\nJames Zhou 19 Male Finally, object values can be modified.\nhuman2.fName = \"Jane\" human2.lName = \"Doe\" human2.age = 23 human2.gender = \"Female\" print(human2.__str__()) Output:\nFirst Name: Jane Last Name: Doe Age: 23 Gender: Female There’s a lot more to talk about but for the sake of brevity, I’ll let you expirement with objects on your own time.\n12.4 Inheritance Inheritance is as the name implies, inheriting traits from a parent class. Continuing with our human class example, suppose a student inherited traits of a human while adding its own unique traits. This makes sense, as all students are humans but not all humans are students.\nHere’s the syntax for inheriting a class:\nclass human(): def __init__(self, fName, lName, age, gender): self.fName = fName self.lName = lName self.age = age self.gender = gender #__str__ returns a string in a legible manner to the user def __str__(self): return \"First Name: \" + self.fName + \"\\nLast Name: \" + self.lName + \"\\nAge: \" + str(self.age) + \"\\nGender: \" + self.gender class student(human): def __init__(self, fName, lName, age, gender, grade, classes, grades, gpa): super().__init__(fName, lName, age, gender) self.grade = grade self.classes = classes self.grades = grades self.gpa = gpa #this __str__ overrides human's original __str__() method def __str__(self): return \"First Name: \" + self.fName + \"\\nLast Name: \" + self.lName + \"\\nAge: \" + str(self.age) + \"\\nGender: \" + self.gender + \"\\n:Grade: \" + str(self.grade) + \"\\nClasses: \" + str(self.classes) + \"\\nGrades: \" + str(self.grades) + \"\\nGPA: \" + str(self.gpa) testHuman = human(\"John\", \"Doe\", 21, \"Male\") print(testHuman.__str__()) testStudent = student(\"John\", \"Doe\", 21, \"Male\", 12, [\"CSE30\", \"MATH19A\", \"WRIT2\"], [\"A\", \"B\", \"A\"], 3.5) print(testStudent.__str__()) Output:\nFirst Name: John Last Name: Doe Age: 21 Gender: Male First Name: John Last Name: Doe Age: 21 Gender: Male :Grade: 12 Classes: ['CSE30', 'MATH19A', 'WRIT2'] Grades: ['A', 'B', 'A'] GPA: 3.5 12.5 Inheritance vs composition I don’t think you’ll need to go over this in depth for your intro CS classes so I’ll just give a really brief summary over this topic.\nInheritance allows you to pass and extend methods from a base class to child classes so you don’t need to rewrite the same code for similar functionality. The problem with inheritance lies in the fact that it’s not very flexible with it’s passing. For our earlier human, student example, let’s say we wanted to add another class to the student like tutor. Class tutor and class student have different properties and characterstics and we can’t extend one while getting the same properties from another class without some wonky workarounds.\nHere’s where the idea of composition comes into play. Instead of inheriting everything from different classes, we should instead try to compose classes from a culmniation of functions and objects.\n13. Recursion Recursion is a very common programming term. Essentially, it is the process of defining and executing something in terms of itself. In other words, it’s performing code blocks repeatedly inside itself or in other functions.\nHere’s an example to visualize recursion in python:\ndef recursiveMultiplication(x, y): if (x*y \u003c 1000): recursiveAddition(x*y, y) else: print(x*y) recursiveMultiplication(5,2) Output:\n1280 In its first iteration, x*y equals 10. 10 is less than 1000 so we call the function again, this time passing in new numbers 10 and 2. 10*2 = 20, which is again less than 1000. The process repeats and eventually we get 1280. Here’s the chain:\n   Iteration x y     1 5 2   2 10 2   3 20 2   4 40 2   5 80 2   6 160 2   7 320 2   8 640 2   9 1280 2    One common bug with recursion is the maximum recusion depth error. This happens when your program never stops recursively calling itself. Think of it as an infinite loop. The problem usually stems from there being no exit case.\nOnce the final recursive loop executes, the program begins to linerally unravel. From the above example, after iteration 9, iteration 8 can finally complete itself. In iteration 8, the if loop was executed but the code underneath it was never run (even though there is nothing there). Once iteration 9 is complete and the print statement is run without another recursive call, iteration 8 can complete itself as the line recursiveAddition(x*y, y) has finally finished executing.\n14. Conclusion This concludes the intro to python guide! If you read all the way through, you should be acquainted with the majority of topics you’re intro CS courses will cover. Please keep in mind that while this guide is long, it was not designed to cover EVERY topic that comes up in your CS classes. In other words, pay attention still! Feel free to come back to this guide as a reference for syntax but also note that there are plenty of other online resouces out there.\nCS is a really fun major and I’m sure you’ll enjoy the process. Enjoy the content and good luck!\n","categories":"","description":"A comprehensive guide covering an introduction to python curtailed towards the curriculum of CSE20 and CSE30.\n","excerpt":"A comprehensive guide covering an introduction to python curtailed …","ref":"/ucsc-guide/docs/majorguides/computerscience/python/","tags":"","title":"Python Guide"},{"body":"Before delving into the specifics of Git, we must first explain what version control is because Git is a version control system. This article will explain what version control is and what’re its benefits.\nDefinition Anything from text documents to software go through cycles of development and revisions to get to the current place that they’re at. Much of the time, multiple people are modifying different things at once or even making conflicting changes, resulting in a non-linear series of changes.\nHow all these issues are dealt with depends on the version control system being used. In essence, anything that allows people to manage changes done to something is a version control system. There are many applications of version control in our daily lives outside of programming. One example of this is being able to check version history and revert changes in Google Docs.\nHow Google Docs implements version control Photo: docs.google.com   We will dive into how Git implements version control in the next article, but for now, we’ll talk about its benefits when it comes to developing software.\n​\n Benefits for developing software Significant pieces of software are virtually never developed completely alone and undergo countless changes. This results in a potentially complicated net of changes which must be kept track of to do things like revert a specific set of changes or keep track of who did what. It is because of this that version control is vital for software development.\nA graph of changes to a project over time. Graph: Made using the Git Graph Visual Studio Code extension   Whatever field of computer science you end up doing, you will always encounter the usage of version control in some way or another, which is why lower division computer science courses such as CSE 12/L and CSE 13 make you get into the habit of using Git. Although the projects you do in those courses will be alone and not with other contributors, it is still extremely useful for reverting bad changes, seeing what was done when, and for other reasons that will be explained in the next article.\n​\n ​\nNow that we’ve covered what version control is, the next article will explain what Git does to implement a version control system to reap the benefits of using it as explained above.\n","categories":"","description":"An explanation of version control and how it pertains to Git.","excerpt":"An explanation of version control and how it pertains to Git.","ref":"/ucsc-guide/docs/majorguides/computerscience/git/fundamentals/what_is_version_control/","tags":"","title":"What Is Version Control?"},{"body":"Summary This group of articles will take you through what version control is, why it is useful, what it has to do with Git, and the basics of Git. It’s okay if you don’t understand everything the first time reading these articles. Read it once or twice and come back to them as you’re reading Basic Git Operations as necessary.\n","categories":"","description":"A guide for how Git and version control works.","excerpt":"A guide for how Git and version control works.","ref":"/ucsc-guide/docs/majorguides/computerscience/git/fundamentals/","tags":"","title":"Git Fundamentals"},{"body":"This section is designed as an introduction into C for use in lower division courses, such as CSE 13S. This section will link to official reference and other resources when possible.\n Prerequisites  A basic understanding of programming concepts, such as variables, if statements, loops, and functions. If you do not have any programming experience, it is highly recommended that you read the section on Python first. A Linux virtual machine or box. (Ubuntu 20.04 recommended) A basic understanding of how the terminal works on your distribution of Linux. If you do have not used a Linux before, it is recommended that you read the section on Unix first.   Background C is a a very simple language. It was developed in the 1970s by Dennis Ritchie. The language was eventually standardized in 1989 by ANSI. This version would become known as ANSI C, also referred to as C89. Over the years, newer versions of the C standard have been published. This section will primarily be covering basic C features up until C99.\n Hello world 1 2 3 4 5 6 7  #include \u003cstdio.h\u003e int main(void) { printf( \"Hello World!\\n\" ); return 0; }   The above code shows one of the ways to write a “Hello World” program in C. A “Hello World” program is a program that prints “Hello World” or some variation to the terminal. This program may look a little intimidating at first for someone who hasn’t seen C code before, but rest assured, each part of the code will be explained eventually through this section’s articles.\nLine 1 shows a #include preprocessor directive. The #include directive will be covered more in-depth in the “Writing programs” section. Preprocessor directives in general will be covered later in the “Building programs” section. For now, all you need to know about this line is that it enables us to use the printf function.\nLine 3 shows a function signature. A function signature contains information about a function. This function in specific is called the main function. When defined, it is the function that is called when the program is run. Functions will be covered later in the “Functions” section.\nLine 4 shows a call to the printf function. In this case, printf is used to print (output) \"Hello World!\\n\" to the standard output. Standard output will be explained in the “Standard Input/Output/Error” section. \\n is put at the end to print a new line. Unlike many other programming languages' print statements/functions/methods, C’s printf does not automatically add a new line at the end of the string to be printed. You will need to do so manually.\nLine 6 makes the program return with error code 0. In C, the main function returns error codes. An error code of 0 indicates that the program exited without an error. A non-zero error code indicates that the program exited with an error. Return statements and values will be covered more in-depth in the “Functions” section.\nIf you are still confused about how this program works, do not worry. Each part of it will eventually be covered in this section’s articles.\nAdditional resources The definitive book on C is The C Programming Language, by Brian Kernighan and Dennis Ritchie (the book is often called “K\u0026R” after the author’s last initials). It’s concise, well-written, and generally a model for excellent technical writing. The second and most recent edition was published all the way back in 1988, but C has not changed much since then, so it is still a great resource. It can easily be found legally (for money) or illegally (for free) online.\n","categories":"","description":"Introduction to C programming.\n","excerpt":"Introduction to C programming.\n","ref":"/ucsc-guide/docs/majorguides/computerscience/cprogramming/","tags":"","title":"C Programming"},{"body":"The proof building skills you gain from this class will be foundational for your success in CSE 102. They may look intimidating but the most comforting advice I have received from my teachers and tutors is that notation is half the problem. Once you work your way through the notations in the problem, you can start to understand what you are looking at and think of approaches to solutions. The following are just previews into common proof techniques from CSE 16 and 102.\n Note: Sometimes professors say which proof technique to use and sometimes it’s not explicitly stated, so you will need to pick a valid proof technique that can get you the desired result. So these are just good skills to keep in mind when creating a proof. Don’t worry - proof get a little easier and make more sense with practice!\n  Contradiction The starting point for a proof by contradiction can be a little tricky, but it is fun when you get the hang of it. A common set up is simply “prove this” and it gives you some expression to prove. The way a proof by contradiction works is that you take the negation of what was given and assme those are True as your “givens” to start with, then you continue using those negated expressions to see if you derive a contradiction (or something that cannot possibly be True). I will give and explain one example below.\nExample Prove the $\\sqrt{2}$ is irrational.\nThe first thing to do in a proof by contraction is to negate what is given and then assume that as a hypothesis.\nWe assume $\\sqrt{2}$ is rational and use various mathematical definitions to try to find a contradiction. The idea here is that we have to explore the world to see what would happen if $\\sqrt{2}$ is indeed rational and look for something that doesn’t make sense. In this problem, we will see that the greatest common divisor between two number is found to be 1 and not 1 at the same time. This is the contradiction because this cannot be true. So we can conclude the $\\sqrt{2}$ is irrational because if was rational then we have shown that a contradiction arises.\n Note: $gcd(a, b)$ is the greatest common divisor between $a$ and $b$. In this problem, we will be concerned about $gcd(a, b) = 1$, which means that $\\frac{a}{b}$ is in its simplest form and $gcd(a, b) \\neq 1$, which means $\\frac{a}{b}$ is not in its simplest form.\n The proof goes like this:\n Assume $\\sqrt{2}$ is rational. This means $\\sqrt{2}$ made up of some $\\frac{a}{b}$ where $a, b \\in \\mathbb{Z}$ and $b \\neq 0$ and $gcd(a, b) = 1$. Now, $\\sqrt{2} = \\frac{a}{b}$. Some rearranging gives, $2 = \\frac{a^2}{b^2}$. Solve for $a^2$ gives $a^2 = 2b^2$. Using a theorem that says if $a^2$ then, $a$ is even too (it’s a fun, quick proof to prove this theorem, try it), we can see that 2 divides $a$ evenly because the theorem says $a$ is even, so it’s a multiple of 2. Then from $2 = \\frac{a^2}{b^2}$, we can solve for $b^2$ to get $b^2 = 2a^2$. Same as above, we can see that $b^2$ is even and it follows that $b$ is even. Now, we have something that doesn’t make sense. We found that $a$ and $b$ are both even, which means that 2 can divide them both, which means $gcd(a, b) \\neq 1$. However, earlier in proof, we stated that the $gcd(a, b)$ is 1. These both cannot be true at the same time, so we can conclude that the $\\sqrt{2}$ is irrational because otherwise there would be an inconsistency.  Formal Proof Rules Before we get to the next techniques, you need to be familiar with what is and how to make a formal proof. In general, these are made with two columns, left side has the mathematical expressions and the work shown and the right side as the name of the rule or explanation of the reasoning that you used to get to that result. A couple rules and then the example to tie it all together:\n Two columns: left has the actual expressions, right has the name of the the rule you applied and the line numbers for the expressions involved. Number each line starting from 1.  I know it is annoying to always “show your work”, but it is easy to get lost or make a small mistake in the proof and then the answer is off or you cannot get to the correct answer. There are many ways to make a proof for a given problem, so these rules are in place to make it clear to the reader how you solved it and to yourself to follow your process to easily backtrack if something went wrong. Believe me, it is a time saver.\n Contrapositive The contrapositive is also an interesting proof technique. This technique uses the fact that $p \\rightarrow q$ is logically equivalent to (i.e. the same as) $\\neg q \\rightarrow \\neg p$. You can check this equivalence for yourself by applying the Definition of Implication to both statements and seeing that they are the same.\nThis may seem a bit unusual but it is incredibly useful to be able to rewrite a given problem in different ways and still maintain the same logical value. You can think of this as the same thing as simplifying or factoring an expression in Calculus - you get the same answer, but the manipulation to the expression makes it easier to work with.\nDefinition of Even and Odd For the example below and for other proofs you may come across it is good to explicitly know the formal definitions of even and odd numbers.\n Odd: The number can be rewritten in the form of $x = 2m + 1$, where $m \\in \\mathbb{Z}$. You can try this with any integer for $m$ and see that $x$ will always be odd. Even: The number can be rewritten in the form of $x = 2m$, where $m \\in \\mathbb{Z}$. You can try this with any integer for $m$ and see that $x$ will always be even.  Example Prove that if $n^2$ is even, then $n$ is even.\nIf you try to prove this directly, it will be quite difficult. So, we will take the contrapositive and prove it indirectly using the 2 column formal proof layout with the math on the left and the reasoning on the right.\nContrapositive: Prove that if $n$ is odd, then $n^2$ is odd.\n  Expressions Reasoning   1. $n$ is odd  Hypothesis 1   2. $n = 2p + 1$, where $p \\in \\mathbb{Z}$ ($p$ is an integer)  Definition of odd   3. $n^2 = (2p + 1)^2$  Logically/Mathematically equivalent to line 2   4. $n^2 = 2(2p^2 + 2p) + 1$  Logically/Mathematically equivalent to line 3 (multiplied the square and factored out 2)   5. $n^2 = 2k + 1$, where $k = 2p^2 + 2p$ and $k \\in \\mathbb{Z}$  Logically/Mathematically equivalent to line 4 (defined a new variable $k$ as an integer)   6. $n^2$ is odd  Logically/Mathematically equivalent to line 5 by the definition of odd   Notice how most of this proof was just applying the formal definition of odd numbers (which you already knew but not formally) and manipulating the expression until something useful came about. There is not too much to explain other than reading the proof and following along because most of it is things you already knew but just slightly more formal!\n Rules of Inference This handout will be your best friend when doing some more formal boolean algebra proofs (see the Proofs section here). Like the previous handout, I will explain one rule from this one so you know how to read and use it when you have a formal proof to solve.\nA reference chart for the rules of inference. Diagram: skedsoft.com\n  (Click here to download the image if you want to save it for safe keeping.)\nNotation in the Rules of Inference The $\\lnot$ symbol is another way is representing a negation/inversion. The $\\therefore$ symbol is called “therefore” and means therefore, you can think of it as an equal sign for now. It will make more sense in the example below. That is all the new notation in the handout! The rest should be explained in previous parts of the guide!\nRules of Inference Example I think the easiest way to understand how to use and read this chart is by making a small proof and walking you through my thought process! I will put the proof up first then explain it under.\nGiven: $(p \\land q) \\rightarrow r$, $p \\rightarrow p$, $q$. Prove $r$.\n  Expressions Reasoning   1. $(p \\land q) \\rightarrow r$  Hypothesis 1   2. $q \\rightarrow p$  Hypothesis 2   3. $q$  Hypothesis 3   4. $p$  Modus Ponens, lines 2 and 3   5. $p \\land q$  Conjunction, lines 3 and 4   6. $r$  Modus Ponens, lines 1 and 5   You are given three “hypotheses”, which are the expressions that are given to you to use to solve for $r$. You are trying to derive $r$ from these three hypotheses. I like to list out the given hypotheses first, so they are there when I want to use them later, but you can write them down you need them as you go through the proof too.\nNow to get to line 4, I look at the rules chart and I see what kind of rules I can apply to any previous lines and see if that gets me anything that can be useful. In this case, I see that Modus Ponens says if you have a line that says $p$ and a line that says $p \\rightarrow q$, you can get $q$ as a result. I know the letters are a bit off but that is okay as long as you keep it consistent, you can make a substitution, so you can temporarily think of the $p$ in the proof as the $q$ in the chart and vice versa.\nThe logic behind Modus Ponens applied to line 4 is that if you have the value of $q$ in line 3 and you have the expression that says $q$ implies the value of $p$, then you can use $q$ you have to get the value of $p$. I think of this one as “unlocking”. I need to get a $q$ because I have something that tells me that $q$ “unlocks” a new value that I need, which is $p$.\nPut into a more concrete example, let’s say $q =$ it is raining and $p =$ get an umbrella. Then you have a line that says $q \\rightarrow p$ (i.e “if it is raining, then get an umbrella). You can observe that is raining, so we have established $q$ to be True (which is what line 3 represents in the proof). We have a statement (the implication arrow) that says what to do if it is raining, so we can conclude $p$ from that, which is to get an umbrella.\nIn line 5 of the proof, this is using the Conjunction rule, which allows you to combine any expressions in the proof so far with an AND ($\\land$) between them. In this case, I see that it would helpful to do that because Hypothesis 1 on line says that if you have $p \\land q$, you can get $r$, which is what we need.\nFinally, I apply Modus Ponens again to lines 1 and 5 to get $r$ from $p \\land q$ and $(p \\land q) \\rightarrow r$.\n Induction Induction is usually the proof technique that is hardest to grasp in my experience working with students, but it gets easier with more practice problems.\nThe easiest introduction to the concept here is to think of a staircase. In order to begin walking on the staircase to get to each next step, you must first get on the very first step, but when you get on the first step, you know know how to get to the next step. So you use that information to get you to each next step until you get to the end.\nIn inductive proofs, it is a similar flow: the first “step in the stair case” is a mathematical expression that must be established as true. Then you use that proven statement to help you prove each next step.\nThere are two types of induction: weak and strong.\nWeak Induction Putting the staircase analogy formally, $p(n) \\rightarrow p(n+1)$, where $n \\in \\mathbb{N}$.\n","categories":"","description":"Introduction to Proofs.\n","excerpt":"Introduction to Proofs.\n","ref":"/ucsc-guide/docs/majorguides/computerscience/discretemath/proofs/","tags":"","title":"Proofs"},{"body":"The knowledge you gain about logic from Discrete Math (CSE 16) and Computer Systems and Assembly Language (CSE 12) will be some of the most commonly used skills in your career because of how frequently we use conditional statements and try to simplify them in code.\nDefinitions  Bit: a bit is a binary value that is a 0 or a 1. Just one, not both, and nothing in between. Binary: a number system used in computer science that has only the numbers 0 and 1. Boolean: only has the value of True or False. Just one, not both, and nothing in between. Proposition: a logical expression that can be evalutated to a True or False value.  Logic Gates This is one of the most common concepts you will come across when doing any programming. So, you will eventually memorize these, if you have not seen them before just from how often you will need to use them. All of the following gates are boolean/binary operations, which means that the inputs and outputs can only be True (1) or False (0) and nothing else and nothing in between.\n AND The AND gate can take in any number of input greater than 1. The truth table for the AND gate and its appearance in digital logic design is shown below.\nIn short, the AND gate returns/outputs a True (1), only when all of its inputs are True (1). It returns/outputs a False (0) otherwise (i.e. when at least one input is False (0) ).\n  Example: You want to check if A AND B AND C AND D are all True (1).\n  Example: You are making a new social media and working on how to have a user create a new account. You need to check if the user entered a valid email AND they are over a certain age AND entered a secure password.\n   OR The OR gate can take in any number of input greater than 1. The truth table for the OR gate and its appearance in digital logic design is shown below.\nIn short, the OR gate returns/outputs a True (1), when at least one of its inputs are True (1). The other inputs can be anything else - there just has to be at least one True (1) in the inputs. It returns/outputs False (0) when all of the inputs are False (0).\n  Example: You want to check if any one of A OR B OR C OR D are True (1).\n  Example: You are making a scheduler. You want to check if the timer for the current task at hand has run out OR if the current task has finished so you can move on to another task. (This is one algorithm that a CPU may use schedule tasks in your computer!)\n   NOT The NOT gate (also called an inverter) can take in 1 input and invert it. The truth table for the NOT gate and its appearance in digital logic design is shown below.\nIn short, if the input is a True (1), then the output is a False (0). If the input is a False (0), then the output is a True (1).\n  Example: You want to invert the truth value of one variable A.\n  Example: You are making a game and want to check when the player in the game is alive or dead so you know to continue the game or display the “game over” message. You make a conditional statement to continue running the game while the player is NOT dead.\n   XOR The XOR gate can take any number of input greater than 1. The truth table for the XOR gate and its appearance in digital logic design is shown below. XOR stands for “exclusive or”, so one or the other but not both. The use of a XOR gate is not as common as the previous gates, but it still comes up and good to know.\nIn short, the XOR gate returns/outputs a True (1), if only 1 of the inputs is True (1) and False (0) otherwise.\n Example: A server sends 4 bits to a client and calculates the XOR of the 4 bits and the result is 1 and appends this resulting bit to the 4 (now 5) bit message to the client. The client can XOR the first 4 bits and if the result of the XOR is not the same as what the 5th bit says, then the message has been corrupted in transmission. But this is not a complete check since the message can be corrupted in a way that the server and client XOR results still line up.   Opposite Gates Each one of the gates above have one that is the opposite as what it is normally. The AND gate has its opposite called NAND gate. OR has NOR. NOT/NO has BUFFER/YES. XOR has XNOR. The truth tables and digital logic design for all of these gates are also below. Essentially, just take the outputs of the normal gate and invert them and that is the truth table for the corresponding opposite gate.\n Truth Tables Truth tables can be tedious to make if there are a lot of inputs, but it is one of the most effective ways to visualize a problem. Similar to how Venn Diagrams are useful to help understand some set theory problems, truth tables are an excellent way to check if two statements are equivalent or not or simply evaluate an expression to see its resulting truth value.\nHere is the visual for all of the logic gates described above. Now let us see how to read it.\nA visual guide to the common logic gates. Diagram: Proprofs.com\n  (Click here to download the image if you want to save it for safe keeping.)\nThe $A$ and $B$ on the left columns are example inputs to the gate. Remember these can only be boolean/binary True (1)/False (0). They can the results of previously evaluated expression or a simple 1 or 0 as you see in the tables.\n Notice that the inputs start at all 0 and then slowly work their way to all 1 at the bottom and that all of these rows make up every single possible combination of inputs that this gate have take. These are only 2 input gates, but you can come up with the tables for more inputs or Google them.\n Now, look at the table one row at a time. Those two inputs get that gate operation applied to them and then the result is in the right side column.\n Laws of Logic This handout will be your best friend when working with logical expressions/equations that you need to evaluate or simplify. I will explain one rule on the handout so you know how to read and use it.\nA reference chart for the laws of logic. Diagram: math.stackexchange.com\n  (Click here to download the image if you want to save it for safe keeping.)\nNotation in the Logic Laws The T and F stand for True and False, respectively. The $p$, $q$, and $r$ used in the diagram are just variables that have boolean values. They can stand for a single variable in an equation or a piece of an expression (ex. $p$ can just be a variable in the equation as $p$ itself like how you can have $x$ in an expression in Calculus OR it can be representative for something bigger than a single variable like how you can have $x = (a + b/2)$ in Calculus). The $\\equiv$ symbol means “logically equivalent” (i.e. equal to). The $\\rightarrow$ symbol is called “the arrow of implication” read in an expression as “implies”. So $p \\rightarrow q$ is read aloud as “$p$ implies $q$”.\n Note: The first one in Table 7 is called “Definition of Implication” and the first one in Table 8 is called “Definition of Equivalence/Biconditional”.\n  Duals Most of the logic laws have everything the same in their equations but the $\\lor$ and $\\land$ signs are flipped ($\\lor$ becomes $\\land$ and $\\land$ becomes $\\lor$). This operation of switching the ANDs and ORs is called “taking the dual”. In other words, one of these laws is the dual of the other (with the same name).\n Note: The Double Negation, Defintion of Implication, and Definition of Equivalence do not have any duals.\n  Logic Law Handout Example Let us take a look at the Commutative Laws. Notice how there are two Commutative Laws.\nFor the first Commutative Law, it says (in English): “the (truth) value of $p$ OR’ed with the (truth) value of $q$ is logically equivalent to the (truth) value of $q$ OR’ed with the (truth) value of $p$”. Notice how this is the same exact thing that you have seen before in previous math classes: $x + y = y + x$… same thing!\n ","categories":"","description":"Introduction to Logic.\n","excerpt":"Introduction to Logic.\n","ref":"/ucsc-guide/docs/majorguides/computerscience/discretemath/logic/","tags":"","title":"Logic"},{"body":"As a UCSC student, the concepts and skills from this lower division class are absolutely essential. The material from Discrete Math shows up many times in upper division courses many times, so it is well worth your time to understand as much as you can from this class now, so later classes are not as challenging as they could be.\n","categories":"","description":"Introduction to Logic, Set Theory, and Proofs.\n","excerpt":"Introduction to Logic, Set Theory, and Proofs.\n","ref":"/ucsc-guide/docs/majorguides/computerscience/discretemath/","tags":"","title":"Discrete Math"},{"body":"Set theory is the branch of mathematical logic that studies sets, which can be informally described as collections of objects. Founded by German mathematicians Richard Dedekind and Georg Cantor in the 1870s (Wikipedia).\nDefinitions Set A collection of objects, where order and repetition does not matter. Sets can hold any type of objects, not strictly 1 character numbers or letters.\nSet Notation Sets are usually surrounded by curly braces with commas separating elements and when assigned to a variable, the convention is to use a single capital letter (although there may be exceptions).\nElement The objects inside a set.\nElement Notation When you want to note a specific element from a set, you use the $\\in$ symbol. When an element is not in a set, you use the $\\notin$ symbol.\n Example: Written as $1 \\in A$. Read/Spoken as “1 is an element of (set) A” OR “1 is a member of (set) A”. Example: Written as $34 \\notin A$. Read/Spoken as “34 is not an element of (set) A” OR “34 is not a member of (set) A”.  Examples $A = \\{1, 2, 3, 4\\}$. $B = \\{a, b, c, d\\}$. $C = \\{cat, dog, cow, fox\\}$.\n Note: If you see “$\\dots$” in a set that means that it should be clear what elements come next infinitely (i.e. this is the pattern for the set and it does not end).\n  Common Sets These are special sets that are used across mathematics and computer science theory (algorithms).\nReal numbers  This set has any decimal number of any precision. Symbol: $\\mathbb{R}$ Examples: 1.0, 388.09384, 3.1415, -1005.6400009  Natural numbers  This set has the counting numbers that you use everyday. Depending on context, they may start with 0 or 1, so be careful. Symbol: $\\mathbb{N}$ Example: $\\{0, 1, 2, 3, 4, \\dots\\}$  Integers  This set has any positive or negative whole number. Symbol: $\\mathbb{Z}$ Example: $\\{\\dots, -3, -2, -1, 0, 1, 2, 3, \\dots\\}$  Rational numbers  This set has the result of dividing any two integers, but not 0 in the deminator. Symbol: $\\mathbb{Q}$ Examples: $\\frac{3}{2}, \\frac{2}{4}, \\frac{-24}{97}$  Empty set  This is the set that has no elements in it. Symbol: $\\emptyset$ OR $\\{\\}$   Cardinality Defintion The size/length of the set.\nNotation Vertical bars around the name of the set.\nExamples  Let $A = \\{1, 2, 3, 4\\}$. The cardinality of set $A = |A| = 4$. Let $B = \\{A, D, G, N, I, Y\\}$. The cardinality of set $B = |B| = 6$.  Some sets are considered countable and some are considered uncountable. Simply, a set is countable if you can use the natural numbers to count the set in question. A set is uncountable if you cannout use the natural numbers to count it. There are also finite and infinite sets. A set is infinite is it has infinitely many elements and finite if it has a finite number of elements.\n Subsets Definition One set is a subset of another if all of the elements of one set can be found in the other.\nNotation $A \\subset B$ OR $A \\subseteq B$. The “$\\subset$” symbol is called “proper subset” and the “$\\subseteq$” is called “subset”.\n Note: There is a little line under the symbol in the second example. This subtle difference between the two symbols is similar to $\u003c$ and $\\le$.\n Example of proper subset Let $A = \\{1, 2, 3, 4\\}$ and let $B = \\{1, 2, 3, 4, 5, 6, 7, 8\\}$. In this case, $A \\subset B$ because all of the elements in set $A$ can be found in set $B$, but $B$ has some elements that $A$ does not. That is how it is written, but when it is read/spoken, you say “(set) $A$ is a proper subset of (set) $B$”.\nExample of subset Let $A = \\{1, 2, 3, 4\\}$ and let $B = \\{1, 2, 3, 4\\}$. In this case, $A \\subseteq B$ because all of the elements in set $A$ can be found in set $B$ and the two sets happen to be the same set. That is how it is written, but when it is read/spoken, you say “(set) $A$ is a subset of (set) $B$”.\nVisually A visual example of subsets and proper subsets Photo: OnlineMathLearning.com\n  (Click here to download the image if you want to save it for safe keeping.)\n Note: The $U$ in the top left corner stands for the “universive of discourse”. You can think of this as the “domain” of the problem, where the universe has all possible values in a given problem.\n  Power Set Definition A power set of a set is the set of all possible subsets that can be made from the original set.\nNotation $\\mathcal{P}(A)$\nExample Let $A = \\{1, 2, 3\\}$. $\\mathcal{P}(A) = { {}, {1}, {2}, {3}, {1, 2}, {1, 3}, {2, 3}, {1, 2, 3} }$.\n Note: A quick check to make sure you didn’t miss a set when making the power set is to count the number of sets in your power set and see if it equals $2^{|A|}$. But this isn’t a complete/exhaustive check, so make sure you get every combination.\n  Note: The empty set is a subset of any set and therfore in every power set.\n  Common Set/Logic Operations You can perform operations on sets. These operations are fairly common in discete math, algorithms, and logic/hardware. Some of the styles of notation may differ across these fields, but they all mean the same.\nUnion/OR This operation is similar to an “addition” of the sets involved, like a combination. Combine the sets involved into one big set, but no duplicates. In set theory it is called “union” and in logic/hardware it is called “OR”.\nNotation Set theory: $A \\cup B$. Logic/hardware: $A \\lor B$.\nExample Let $A = \\{1, 2, 3\\}$ and let $B = \\{3, 4, 5, 6\\}$. The union of sets $A$ and $B$ is $\\{1, 2, 3, 4, 5, 6\\}$.\n Intersection/AND This operation is finding the commonalities bewtween the sets involved. In set theory it is called “intersection” and in logic/hardware it is called “AND”.\nNotation Set theory: $A \\cap B$. Logic/hardware: $A \\land B$.\nExample Let $A = \\{1, 2, 3\\}$ and let $B = \\{3, 4, 5, 1\\}$. The intersection of set $A$ and $B$ is $\\{1, 3\\}$.\n Complement/NOT In set theory, this operation is finding what is not in the set in question, but in logic/hardware, this operation is taking the opposite of a True/False value. This operation can be done in addition to other operations on one or more sets. It is also called a “negation”.\nNotation Set theory: $A^C$. Logic/hardware: $\\bar{A}$ or $A'$, or $\\sim A$.\nExamples Let the universe $U = \\{1, 2, 3, 4, 5, 6\\}$. Let $A = \\{1, 2, 3\\}$. Let $B = \\{3, 4, 5, 1\\}$.\n $A^C = \\{4, 5, 6\\}$ $\\overline{A \\cup B} = \\{6\\}$   Note: In the last example, I used a very famous law/rule called DeMorgan’s Law, which will be left up to you to Google (very simple, but incredibly powerful trick). In short, DeMorgan’s Law lets you move a negation in and out of parantheses while maintaining the correctness of the answer.\n Visually A visual example of subsets and proper subsets Photo: OnlineMathLearning.com\n  (Click here to download the image if you want to save it for safe keeping.)\n Note: Venn Diagrams are incredibly useful to visualize some of the set operations in more complicated problems that involve more than 2 simple, small sets. So if you are having trouble wrapping your head around a problem or operation when solving a problem, draw it out!\n ","categories":"","description":"Introduction to Set Theory.\n","excerpt":"Introduction to Set Theory.\n","ref":"/ucsc-guide/docs/majorguides/computerscience/discretemath/settheory/","tags":"","title":"Set Theory"},{"body":"","categories":"","description":"Your guide to lower divsion computer science courses and concepts at UCSC.\n","excerpt":"Your guide to lower divsion computer science courses and concepts at …","ref":"/ucsc-guide/docs/majorguides/computerscience/","tags":"","title":"Computer Science"},{"body":"I got a house close to the base of campus in Summer 2020 and this is an approximate sequence of events and resources I found (but not necessarily used) to help get a place to live.\n Picking Your Group UCSC Community Rentals - Before You Rent\nThe most important thing I would do before even starting to look for a house is to find a solid group of people to live with. Personally, I think a group of 3 - 5 people is a great middle ground for house cleanliness and fun but also somewhat private and quiet to study. Make sure you talk about everyone’s preferences, living condition/way of living, and price ranges. It is very competitive to find housing in Santa Cruz, so you want to pick a solid group who can communicate and be ready to apply to maximize chances of getting the house. You should be doing this around February.\n Starting Your Search After you have your group picked out, have everyone in the group start searching any and all websites for house listings that match the group’s preferences, while simulateously filling out a renter’s application packet. Some landlords ask for it and some don’t, but it takes a little while to put together, so start early. See the link above for more information on it. This also the time to take the quick Canvas Renter’s Workshop. Some landlords ask that you complete it and show the certificate of completion (mine did), but even if they don’t ask, there is still some good information in there about off campus housing in general. You should be doing this in February - March.\n Links for Your Search Here is a list of sites to search for (in no particular order, not exhaustive):\n Zillow (this is where I found my house) Apartments.com Realtor.com Craigslist Santa Cruz Housing Facebook Public Group UCSC Housing, Sublets \u0026 Roommates Facebook Private Group University of California, Santa Cruz (UCSC) Housing, Sublets \u0026 Roommates Facebook Private Group   Contacting Potential Landlords Keep searching all the sites you can and when you reach out to landlord via email or text (however they prefer), I would recommend only having one person communicating with the landlord and then they will convey the updates to the rest of the group - it is usually much more oragnized and less confusing to keep track of who is talking to who. You should be doing this starting in March - April.\nWhen you first contact a landlord to express interest in their listing, I recommend you do the following:\n quickly introduce yourself and your group - names, majors, year express interest in that specific listing - give the address of the place so they know which one in case they have more than one try to sell yourself and your group a little - make yourselves sound like good tenants (and make sure that is the reality too) ask about availability for a tour, applying, and signing the lease so they can get a feel that you are serious about securing this house.  Keep this initial email/text with the landlord SHORT. Get to the point - housing is competitive in Santa Cruz, so you don’t want to deter landlords with a long essay. Make it easier for them.\n Note: This process of searching for potential houses and contacting landlords usually takes a while, so be patient and keep searching. Many landlords will ghost you, leave you on read, or take a while to reply. Don’t take it personal and just move on to the next.\n Pay attention to the date the house is available for new tenants if it is mentioned in the listing online. If it isn’t online you can ask about it in the initial email, but it will be in the lease. I prefer a start date/time that is anytime outside the school year in case my group doesn’t want to resign for another year or we get kicked out, we won’t be doing this whole process again while taking classes. Most leases are 12 months long, so you will be paying for the summer months rent anyway, but you can ask for a month to month lease or a term shorter than 12 months (although landlords do not prefer this).\n Reading the Lease After engaging in talks with landlord and you seem to have a place that will be yours, the landlord will send you the lease and give you a little bit of time to read and sign it. Please read the lease completely.\n Note: Look for contradictions, unfair rules, things that stand out or don’t make sense, and ask for clarification. Make sure you, your group, and the landlord are all in agreement about the terms of the lease BEFORE signing. If you don’t read the whole thing, then at the very least, read the first couple pages since that is where the main points are usually.\n  Move In and Things to Set Up Next is to pay your (refundable) safety deposit, get the keys, and move in! Congratulations! Some houses are prefunished, but I would say most are not. So figure out if anything comes with the house and fill in the missing furniture or appliances with your group.\nRead the terms of your lease to remember what utilities (PG\u0026E, water, trash, cable/internet) you are and not responsible for paying and get those set up. I would say that usually one person takes responsiblilty to pay for one utility to make it fair and everyone pays them back.\n Note: start setting up the utilities (especially internet) as soon as you get the keys to make sure you have a smooth start.\n Be a good housemate, roommate, neighbor, and tenant. It isn’t technically your house, but you should be treating as if it is (or risk losing a lot of your safety deposit)!\n More resources  Community Rentals - (ucsc site) has many more links and resources to help Places4Students - place to find rentals and housemates Legal Services \u0026 Consulation - free access to an attorney for UCSC students if you have legal concerns regarding off campus housing (offered via UCSC Dean of Students) Community Rentals - Questions to Ask - questions to ask the landlord  ","categories":"","description":"How and when to secure a house or apartment off campus.\n","excerpt":"How and when to secure a house or apartment off campus.\n","ref":"/ucsc-guide/docs/housing/offcampus/house_apartment/","tags":"","title":"House/Apartment"},{"body":"Hello! Welcome to UCSC and the Unofficial UCSC Student Guide. Congratulations on your admission to UC Santa Cruz!\nFor new/prospective students This guide’s purpose is to introduce new students to UCSC student life through tips and experiences shared from experienced, fellow UCSC peers. It seems that many UCSC sites are hard to navigate and not incredibly informative since they lack student opinions, so this guide will complement much of the important information from the UCSC sites with student perspectives and thoughts to give new students a more realistic and holistic introduction to UCSC.\n For current/returning students Some of the information in the Guide may already be known to you and some of it may not. If you find something to be inaccurate or would like to add more information, please let me know or see the Contribution Guidelines if you would like to try making a fix yourself!\n Site navigation and use There is a navigation bar on the left-hand side that will categorize all the different sections of the Guide, ranging from off campus housing to preparation for your major studies to student employment. Relevant links from UCSC sites and other official sources will be put as much as possible throughout the Guide so you can always trace back this summarized information to the source to verify its authenticity.\nThe right side of each page will have links to the different subsections of that page for easy access to particular information you are looking for or just to act as a summary of what the current page has.\nThe bottom of each page will have a link to the next section if you want to read and click through in order, but you can pick and choose any section from the navigation bar. The time the site was last updated will also be on the bottom of each page, so you know how up-to-date the information is.\nWe will try to put up as many preparation guide for as many majors as we can, but most of our contributors are computer science majors, so our expertise in other fields are not good enough to know how to make an appropriate guide for other programs of study. For these other majors, we will contact other students and department advising offices to put something together. This will be something along the lines of a “Things I wish I knew before starting [Your Major] at UCSC”.\nThere will also be more general UCSC student information in addition to specific majors and programs, such as info on dining halls, on/off campus housing, residential colleges, and financial aid guides.\n Disclaimer This guide is in no way affiliated with UC Santa Cruz, the Regents of the University of California, or the University of California. It is an unofficial guide put together by UCSC students.\n","categories":"","description":"Start your journey through the Guide here.\n","excerpt":"Start your journey through the Guide here.\n","ref":"/ucsc-guide/docs/","tags":"","title":"How to Use This Guide"},{"body":"","categories":"","description":"Off campus, but through UCSC housing in downtown Santa Cruz.\n","excerpt":"Off campus, but through UCSC housing in downtown Santa Cruz.\n","ref":"/ucsc-guide/docs/housing/offcampus/utc/","tags":"","title":"University Town Center"},{"body":"In the last article, we talked about what version control was. Now, we’re going to cover how Git implements it.\nNote: As stated in Fundamentals, it’s okay if you don’t understand the stuff covered in here immediately. Read through the article then go to Basics, rereading this article as necessary.\nFundamentals of Git Git is a version control system which allows you to log changes made, reasons behind them, push these changes to replicate it in an external place, pull in changes from that external place to other places like another device, and more.\nRepositories (Repos) A repository, or repo, is a collection files and directories (folders) in which changes can be made. Most Git repos are used for storing a unit of software, like a program. Repos stored in different places are called different things. A local repo is one that is on your own computer/device while a remote repo is one that is on an external server. These external servers can be hosted by various places. For example, UCSC hosts a GitLab server, which implements Git. However, they can also be places like GitHub or GitLab’s own servers rather than something self-hosted like the school’s servers on.\nAn example of how to interact with a local repository. Photo: Git Bash Windows console   An example of a remote repository on Github. Photo: github.com   Creating repositories We won’t get into exactly how to do anything until Basic Git Operations, but we’ll describe the the process for now. There are two main ways to create a local repo. The first is to clone it from an existing repo, usually a remote one. The other is to initialize it using the command line. How to create a remote repo depends on where the repo is stored. When it comes to a repo for classes, they will generally be pre-made on the school’s GitLab server and shared with you. However, you can also create repos by navigating to the website and using it to create one, which is also the same way to create a remote repo on sites like GitHub and GitLab.\nMaking changes to repositories As stated earlier, version control provides a way to track changes made. The way Git implements this is through something called commits, commit history, and branches. Commits made on local repos can be pushed to remote repos so that they’re replicated. We’ll explain this in further detail in Basic Git Operations, but this system of being able to make local repositories by cloning remote repositories and pushing changes to transfer them to a remote repo creates redundancies so that your changes persist even if your device’s HDD or SSD fail.\nCommits Commits are a unit of changes to a file or batch of files labelled with a title and description. In Git, every individual commit stores changes made from the previous commit, building on top of them instead of storing the entire repo’s state. We will go over how to create them in Basic Git Operations.\nCommit History As the name suggests, commit history is made up of past commits. Because each commit builds off of the last one, the visible commit history must be linear within a given branch (explained below) so it leads from the original state to the current state.\nAn example of the commit history of a repo. Photo: Git Bash Windows console   Branches By default, all repos created have one branch, the main or master branch. A branch consists of a series of commits and new ones can be created by branching off from another branch. There are many operations that can be done with branches, but we won’t be getting into them because they’re not needed for the lower division courses.\nGetting Git on a local computer To actually use Git on your computer, you first need to get it. If you’re in or going into CSE 12/L, you’ll need to use Git for Windows. If you’re in or going into CSE 13, you’ll be using Ubuntu. Ubuntu and MacOS in most cases should both come with Git by default. However, if you’re on Windows, this isn’t the case. If the Git command isn’t available via the command line, download it from here.\nMaking an account for remote repositories Now that we’ve covered what repos and commits are, it’s time to do some set-up prior to actually using Git.\nTo make an account for school-related remote repos which you’ll use in many computer science classes, go to the school’s self-hosted GitLab site. When creating a school account, do not use another site like GitLab directly or GitHub. Use your school email for the email, Cruz ID for your username, and make a password to register.\nIf you want to create an account on a site hosting remote repositories to put personal projects in to using Git, use a site like GitHub or GitLab.\n Once you create an account, go to the next article, which will explain how to set up an SSH key for Git so that you can push and pull changes to/from the remote repository without having to authenticate using your password.\nNote: There are a lot more features Git has to provide apart from the ones listed in this article. As mentioned in Git, the primary purpose of these articles is have enough knowledge about Git to get through the lower division courses.\n","categories":"","description":"An explanation on what exactly Git is.","excerpt":"An explanation on what exactly Git is.","ref":"/ucsc-guide/docs/majorguides/computerscience/git/fundamentals/how_git_works/","tags":"","title":"How Git Works"},{"body":"In the last article, you got Git on your computer if it wasn’t already installed and created an account for Git on either the school’s or some other remote repo site. There is one more optional but highly recommended step we must go through before actually using Git, setting up an SSH key.\nBackground When interacting with a remote repo, you must authenticate yourself so that the remote repo hosts know you really are who you say you are. This is because it would be a huge security flaw if anyone could modify anyone’s repo without the proper permissions.\nThere are two protocols that can be used to do this in Git, HTTPS and SSH. In the simplest terms, a protocol is a way something gets done. HTTPS and SSH are both cryptographically secure ways to transmit data from one point to another (the servers hosting the remote repo to your computer and vice-versa in this case) through the Internet. You likely have seen HTTPS before at the beginning of URLs because this is one of the main protocols used to send data from you to a website and vice-versa. The reason why it’s recommended to use SSH over HTTPS is that when authenticating over HTTPS, you have to type your username and password of the account you made on the site of the remote repo host, which can be quite inconvenient. This is as opposed to SSH where you’re authenticated automatically once you set it up.\nTo do this, you must generate an SSH key pair, one public key and one private key. Afterwards, you must store the keys on your computer, and give the remote repo host a copy of the public key. The private key is sensitive because it’s used for authentication purposes so keep it safe and don’t give it out.\nGenerating SSH keys and storing them on your device If you’re using Windows, open Git Bash. If you’re on a Mac or Linux, open Terminal. Then, type ssh-keygen -t RSA -b 4096. This will generate a public and private SSH key using RSA-4096 as the encryption algorithm.\nYou will then be prompted for where to store the private key file. Press Enter/Return so that it gets stored in the default place. If it’s asking whether to overwrite a file called id_rsa or not, then type N, press enter/return, and skip to the Giving the public key to the remote repo host.\nAfter this, you will be prompted to create a passphrase. As an added security measure, SSH private keys can be further protected with a passphrase. However, if you’re using a personal computer and it’s just for school or personal projects, you can just press enter and leave the passphrase blank because it isn’t much of a concern in that case.\nNow that the public/private key pair is generated, we will now need to give the public key to the remote repo host, allowing us to authenticate automatically.\nGiving the public key to the remote repo host This next step depends on what host is being used, such as Gitlab, the school’s self-hosted GitLab server, or GitHub, but it’s all generally the same process. First, go to your account settings/preferences on the remote repo site. Then, find the settings tab/page for SSH keys.\nWhat the SSH Keys section in the settings for GitHub look like Photo: github.com   What the SSH Keys section in the settings for GitLab look like Photo: gitlab.com   [picture of GitHub SSH settings] [picture of GitLab SSH settings]\nOnce the page is open, navigate to the user directory by typing cd ~ into Git Bash on Windows or Terminal for Mac and Linux.\nThen, if you’re on Windows, type cat id_rsa.pub | clip.\nIf you’re in Mac, type cat id_rsa.pub | pbcopy.\nIf you’re on Linux, then type cat id_rsa.pub and find the shortcut to copy the output from Terminal, including the lines marking the beginning and end of the key.\nIt is extremely important that you type it with the .pub extension to copy the public key. Once it’s copied paste the key into the appropriate text-box on the SSH key settings page in your browser, setting the expiration date to never if there is an option for that and give the key a title telling what device the key is for. When you’ve typed all the information, add the key.\n This concludes this group of articles. The next group of articles, Basics, will talk about how to do many of the operations that were described in How Git Works.\n","categories":"","description":"An explanation of SSH keys for Git","excerpt":"An explanation of SSH keys for Git","ref":"/ucsc-guide/docs/majorguides/computerscience/git/fundamentals/ssh_keys/","tags":"","title":"SSH Keys"},{"body":"","categories":"","description":"Your guide to on and off campus housing.\n","excerpt":"Your guide to on and off campus housing.\n","ref":"/ucsc-guide/docs/housing/","tags":"","title":"Housing"},{"body":"","categories":"","description":"Your guide to each major at UCSC.\n","excerpt":"Your guide to each major at UCSC.\n","ref":"/ucsc-guide/docs/majorguides/","tags":"","title":"Major Guides"},{"body":"","categories":"","description":"Your guide to off campus housing.\n","excerpt":"Your guide to off campus housing.\n","ref":"/ucsc-guide/docs/housing/offcampus/","tags":"","title":"Off Campus Housing"},{"body":"The ten colleges are listed below in order of when they were founded from first to most recent. Applications for on-campus housing for the following school year open in Spring Quarter. There is a priority application and a regular application period. On-campus housing usually very competitive and based on a point system. You acquire more points by seniority and housing with people from the same college affiliation.\n","categories":"","description":"Your guide to on campus housing.\n","excerpt":"Your guide to on campus housing.\n","ref":"/ucsc-guide/docs/housing/oncampus/","tags":"","title":"On Campus Housing"},{"body":"Hello and thank you for wanting to contribute to the project! All experience levels are welcome! Please take a look at HELPWANTED.md to see items that are outside of the current team’s expertise that need help to expand the scope of the project.\nThe Unofficial UCSC Student Guide is an open source project and welcome to patches, contributions, and improvements!\nThe Guide lives on GitHub. You can view all of its source code there.\n For those inexperienced with programming: Create an issue If there’s something you’d like to see in The Guide (or if you’ve found something that isn’t working the way you’d expect), but you’re not sure how to fix it yourself, please create an issue or contact Hilal via email (hamorrar@ucsc.edu) or Discord (hmorrar#1632).\n For those experienced with programming: Initial setup The guide uses the extended version of hugo with the Docsy theme.\n Install Git. Install Node (and its dependencies if on Windows). Download and install the extended version of Hugo (linked above). You can also use snap to install the extended version of Hugo with sudo snap install hugo --channel=extended. snap works with a lot of Linux distros, and is pre-installed with some major distros such as Ubuntu 16.04+. Fork the repository on GitHub. Use the recursive tag when cloning your fork so that all the submodules are also downloaded: git clone --recursive git@github.com:your-username/ucsc-guide.git cd ucsc-guide to navigate into the project. Install all the dependencies: npm install. Use the hugo serve or hugo server command to start the server. If you would like to expose the website to your network, use hugo serve --bind 0.0.0.0 or hugo server --bind 0.0.0.0. This is useful for accessing the site from another machine when you are using a GUI-less OS to run the site. Open a browser and go to https://localhost:1313/ucsc-guide.  Notes for Hugo development The repository looks a bit intimidating at first, but most of it is all set up from Hugo initially. Most of the work will be done in the /content/en/docs directory to write up articles in Markdown. When previewing changes locally, be careful of the draft value in the top of the Markdown file you are working in. If it is set to true, it will not show up in the final build, but it will show up in a preview only if you use the -D flag in when starting the local server. Every article page you want to write has to have those preamble lines (Hugo calls it “front matter”) at the top for it to render correctly (or at all). You can copy and paste from another file and modify the appropriate fields.\n title is the title of the article linkTitle is what will show up in the left navigation bar author is the author of the article date is the date the article was written in YYYY-MM-DD format weight is for ordering the pages in the directory for the left navigation bar icon is if you want to put an emote next to the title in the left navigation bar from Font Awesome draft is to publish the file on the site if it is in the main branch (false - not a draft. true - is a draft) description is a quick one line summary/preview/subtitle for the article to display under the main title on the page  Create a pull request and preview locally Continue with the usual GitHub workflow to edit files, commit them, push the changes up to your fork, and create a pull request. For more general information on how to contribute to open source projects, check out Open Source Guides. Please follow similar writing style in new contributions.\nSteps to contribute:\n Fork the repository. Clone your fork to your machine. Create or checkout an/the appropriate branch. Commit your changes. Push to your fork of the repo. Make a Pull Request for review.  Conventions When creating or editing pages, we follow certain conventions to ensure consistency across the codebase and articles. These conventions are listed below.\nConventions:\n Folders and subfolders within /content/en/docs are to be PascalCase. Files within /content/en/docs and its subfolders are to be snake_case. An exception to this convention is index files. Index files should be named _index.md. Article titles are to be Title Case. Article subheadings are to be Sentence case. Commit messages are to be descriptive. They must describe the commit accurately and concisely.  Code reviews Submissions will be reviewed by at least one person (Hilal). We use GitHub pull requests for this purpose. Consult GitHub Help for more information on using pull requests.\n Code of conduct This project follows the Contributor Covenant Code of Conduct.\nLicense By contributing, you agree that your contributions will be licensed under the GNU General Public License v3.0 license.\n","categories":"","description":"How to contribute to the Unofficial UCSC Student Guide.\n","excerpt":"How to contribute to the Unofficial UCSC Student Guide.\n","ref":"/ucsc-guide/docs/contribution_guidelines/","tags":"","title":"Contribution Guidelines"},{"body":"Summary The articles here will go through the knowledge you should know when it comes to Git and version control for the lower division courses such as CSE 12/L and CSE 13.\n","categories":"","description":"A tutorial for Git","excerpt":"A tutorial for Git","ref":"/ucsc-guide/docs/majorguides/computerscience/git/","tags":"","title":"Git"},{"body":"","categories":"","description":"","excerpt":"","ref":"/ucsc-guide/categories/","tags":"","title":"Categories"},{"body":"","categories":"","description":"","excerpt":"","ref":"/ucsc-guide/tags/","tags":"","title":"Tags"},{"body":"  #td-cover-block-0 { background-image: url(/ucsc-guide/slug-background_hu07d0d2c1dee64a58563c07828b576f50_918235_960x540_fill_q75_catmullrom_top.jpg); } @media only screen and (min-width: 1200px) { #td-cover-block-0 { background-image: url(/ucsc-guide/slug-background_hu07d0d2c1dee64a58563c07828b576f50_918235_1920x1080_fill_q75_catmullrom_top.jpg); } }  Welcome to the Unofficial UCSC Student Guide! Get Started   Contribute   A (semi-comprehensive, work in progress) guide for UCSC students.\n         The Unofficial UCSC Student Guide is made for UCSC students, by UCSC students. The purpose of this guide is provide quick and easily accessible resources and information for most student concerns by making a single site that has everything you need to know to succeed at UCSC.\n      Searchable site!  Use the search bar in the top right corner to search the documentation or click the Get Started button to view the guide.\n   Contributions welcome!  We do a Pull Request contributions workflow on GitHub. If you are new to contributing, do not fear, check out the contribution guidelines!\nRead more …\n   For UCSC students, by UCSC students!  This guide is composed of articles written by several contributors. We are always looking to improve the information in this guide and hope that you will help out where you can!\n    ","categories":"","description":"","excerpt":"  #td-cover-block-0 { background-image: …","ref":"/ucsc-guide/","tags":"","title":"Unofficial UCSC Student Guide"}]